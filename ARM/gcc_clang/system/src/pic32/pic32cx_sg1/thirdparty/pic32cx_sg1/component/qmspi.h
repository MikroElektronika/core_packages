/*
 * Component description for QMSPI
 *
 * Copyright (c) 2023 Microchip Technology Inc. and its subsidiaries.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

/* file generated from device description file (ATDF) version 2020-03-24T11:15:30Z */
#ifndef _0525SG12_QMSPI_COMPONENT_H_
#define _0525SG12_QMSPI_COMPONENT_H_

/* ************************************************************************** */
/*   SOFTWARE API DEFINITION FOR QMSPI                                        */
/* ************************************************************************** */

/* -------- QMSPI_MODE : (QMSPI Offset: 0x00) (R/W 32) QMSPI Mode Register -------- */
#define QMSPI_MODE_RESETVALUE                 _UINT32_(0x00)                                       /*  (QMSPI_MODE) QMSPI Mode Register  Reset Value */

#define QMSPI_MODE_ACT_Pos                    _UINT32_(0)                                          /* (QMSPI_MODE) This bit is used to activate the QMSPI block.\n     1=Enabled. The block is fully operational\n                 0=Disabled. Clocks are gated to conserve power and the output signals are set to their inactive state. Position */
#define QMSPI_MODE_ACT_Msk                    (_UINT32_(0x1) << QMSPI_MODE_ACT_Pos)                /* (QMSPI_MODE) This bit is used to activate the QMSPI block.\n     1=Enabled. The block is fully operational\n                 0=Disabled. Clocks are gated to conserve power and the output signals are set to their inactive state. Mask */
#define QMSPI_MODE_ACT(value)                 (QMSPI_MODE_ACT_Msk & (_UINT32_(value) << QMSPI_MODE_ACT_Pos)) /* Assigment of value for ACT in the QMSPI_MODE register */
#define QMSPI_MODE_SOFT_RST_Pos               _UINT32_(1)                                          /* (QMSPI_MODE) Writing this bit with a 1 will reset the Quad SPI block. It is self-clearing. Position */
#define QMSPI_MODE_SOFT_RST_Msk               (_UINT32_(0x1) << QMSPI_MODE_SOFT_RST_Pos)           /* (QMSPI_MODE) Writing this bit with a 1 will reset the Quad SPI block. It is self-clearing. Mask */
#define QMSPI_MODE_SOFT_RST(value)            (QMSPI_MODE_SOFT_RST_Msk & (_UINT32_(value) << QMSPI_MODE_SOFT_RST_Pos)) /* Assigment of value for SOFT_RST in the QMSPI_MODE register */
#define QMSPI_MODE_CPOL_Pos                   _UINT32_(8)                                          /* (QMSPI_MODE) Polarity of the SPI clock line when there are no transactions in process. 1=SPI Clock starts High; 0=SPI Clock starts Low. Position */
#define QMSPI_MODE_CPOL_Msk                   (_UINT32_(0x1) << QMSPI_MODE_CPOL_Pos)               /* (QMSPI_MODE) Polarity of the SPI clock line when there are no transactions in process. 1=SPI Clock starts High; 0=SPI Clock starts Low. Mask */
#define QMSPI_MODE_CPOL(value)                (QMSPI_MODE_CPOL_Msk & (_UINT32_(value) << QMSPI_MODE_CPOL_Pos)) /* Assigment of value for CPOL in the QMSPI_MODE register */
#define QMSPI_MODE_CHPA_MOSI_Pos              _UINT32_(9)                                          /* (QMSPI_MODE) Clock phase of the Master data out. Common SPI modes require this field to be programmed with the same value as CHPA_MISO in this register.\n     e.g. Mode 0: CPOL=0; CHPA_MISO=0; CHPA_MOSI=0; Mode 3: CPOL=1; CHPA_MISO=1; CHPA_MOSI=1. See datasheet for alternate mode settings.\n                 If CPOL=1: 1=Data changes on the falling edge of the SPI clock; 0=Data changes on the rising edge of the SPI clock\n                 If CPOL=0: 1=Data changes on the rising edge of the SPI clock; 0=Data changes on the falling edge of the SPI clock Position */
#define QMSPI_MODE_CHPA_MOSI_Msk              (_UINT32_(0x1) << QMSPI_MODE_CHPA_MOSI_Pos)          /* (QMSPI_MODE) Clock phase of the Master data out. Common SPI modes require this field to be programmed with the same value as CHPA_MISO in this register.\n     e.g. Mode 0: CPOL=0; CHPA_MISO=0; CHPA_MOSI=0; Mode 3: CPOL=1; CHPA_MISO=1; CHPA_MOSI=1. See datasheet for alternate mode settings.\n                 If CPOL=1: 1=Data changes on the falling edge of the SPI clock; 0=Data changes on the rising edge of the SPI clock\n                 If CPOL=0: 1=Data changes on the rising edge of the SPI clock; 0=Data changes on the falling edge of the SPI clock Mask */
#define QMSPI_MODE_CHPA_MOSI(value)           (QMSPI_MODE_CHPA_MOSI_Msk & (_UINT32_(value) << QMSPI_MODE_CHPA_MOSI_Pos)) /* Assigment of value for CHPA_MOSI in the QMSPI_MODE register */
#define QMSPI_MODE_CHPA_MISO_Pos              _UINT32_(10)                                         /* (QMSPI_MODE) Clock phase of the Master data in. Common SPI modes require this field to be programmed with the same value as CHPA_MOSI in this register.\n     e.g. Mode 0: CPOL=0; CHPA_MISO=0; CHPA_MOSI=0; Mode 3: CPOL=1; CHPA_MISO=1; CHPA_MOSI=1. See datasheet for alternate mode settings.\n                 If CPOL=1: 1=Data are captured on the rising edge of the SPI clock; 0=Data are captured on the falling edge of the SPI clock\n                 If CPOL=0: 1=Data are captured on the falling edge of the SPI clock; 0=Data are captured on the rising edge of the SPI clock Position */
#define QMSPI_MODE_CHPA_MISO_Msk              (_UINT32_(0x1) << QMSPI_MODE_CHPA_MISO_Pos)          /* (QMSPI_MODE) Clock phase of the Master data in. Common SPI modes require this field to be programmed with the same value as CHPA_MOSI in this register.\n     e.g. Mode 0: CPOL=0; CHPA_MISO=0; CHPA_MOSI=0; Mode 3: CPOL=1; CHPA_MISO=1; CHPA_MOSI=1. See datasheet for alternate mode settings.\n                 If CPOL=1: 1=Data are captured on the rising edge of the SPI clock; 0=Data are captured on the falling edge of the SPI clock\n                 If CPOL=0: 1=Data are captured on the falling edge of the SPI clock; 0=Data are captured on the rising edge of the SPI clock Mask */
#define QMSPI_MODE_CHPA_MISO(value)           (QMSPI_MODE_CHPA_MISO_Msk & (_UINT32_(value) << QMSPI_MODE_CHPA_MISO_Pos)) /* Assigment of value for CHPA_MISO in the QMSPI_MODE register */
#define QMSPI_MODE_CLK_DIV_Pos                _UINT32_(16)                                         /* (QMSPI_MODE) The SPI clock divide in number of system clocks. A value of 1 divides the master clock by 1, a value of 255 divides the master clock by 255. A value of 0 divides the master clock by 256. Position */
#define QMSPI_MODE_CLK_DIV_Msk                (_UINT32_(0x1FF) << QMSPI_MODE_CLK_DIV_Pos)          /* (QMSPI_MODE) The SPI clock divide in number of system clocks. A value of 1 divides the master clock by 1, a value of 255 divides the master clock by 255. A value of 0 divides the master clock by 256. Mask */
#define QMSPI_MODE_CLK_DIV(value)             (QMSPI_MODE_CLK_DIV_Msk & (_UINT32_(value) << QMSPI_MODE_CLK_DIV_Pos)) /* Assigment of value for CLK_DIV in the QMSPI_MODE register */
#define QMSPI_MODE_Msk                        _UINT32_(0x01FF0703)                                 /* (QMSPI_MODE) Register Mask  */


/* -------- QMSPI_CTRL : (QMSPI Offset: 0x04) (R/W 32) QMSPI SPI Control -------- */
#define QMSPI_CTRL_RESETVALUE                 _UINT32_(0x00)                                       /*  (QMSPI_CTRL) QMSPI SPI Control  Reset Value */

#define QMSPI_CTRL_TX_MODE_Pos                _UINT32_(0)                                          /* (QMSPI_CTRL) This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either \n     TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n                  3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. Position */
#define QMSPI_CTRL_TX_MODE_Msk                (_UINT32_(0x3) << QMSPI_CTRL_TX_MODE_Pos)            /* (QMSPI_CTRL) This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either \n     TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n                  3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. Mask */
#define QMSPI_CTRL_TX_MODE(value)             (QMSPI_CTRL_TX_MODE_Msk & (_UINT32_(value) << QMSPI_CTRL_TX_MODE_Pos)) /* Assigment of value for TX_MODE in the QMSPI_CTRL register */
#define QMSPI_CTRL_TX_TRANS_EN_Pos            _UINT32_(2)                                          /* (QMSPI_CTRL) This field bit selects the transmit function of the SPI interface.\n                 3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used.\n                 2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n                 1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n                 0=Transmit is Disabled. Not data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. Position */
#define QMSPI_CTRL_TX_TRANS_EN_Msk            (_UINT32_(0x3) << QMSPI_CTRL_TX_TRANS_EN_Pos)        /* (QMSPI_CTRL) This field bit selects the transmit function of the SPI interface.\n                 3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used.\n                 2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n                 1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n                 0=Transmit is Disabled. Not data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. Mask */
#define QMSPI_CTRL_TX_TRANS_EN(value)         (QMSPI_CTRL_TX_TRANS_EN_Msk & (_UINT32_(value) << QMSPI_CTRL_TX_TRANS_EN_Pos)) /* Assigment of value for TX_TRANS_EN in the QMSPI_CTRL register */
#define QMSPI_CTRL_TX_DMA_EN_Pos              _UINT32_(4)                                          /* (QMSPI_CTRL) This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either\n     the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n                 2=DMA is enabled and set to 2 Bytes\n                 3=DMA is enabled and set to 4 Bytes.\n     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware Position */
#define QMSPI_CTRL_TX_DMA_EN_Msk              (_UINT32_(0x3) << QMSPI_CTRL_TX_DMA_EN_Pos)          /* (QMSPI_CTRL) This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either\n     the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n                 2=DMA is enabled and set to 2 Bytes\n                 3=DMA is enabled and set to 4 Bytes.\n     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware Mask */
#define QMSPI_CTRL_TX_DMA_EN(value)           (QMSPI_CTRL_TX_DMA_EN_Msk & (_UINT32_(value) << QMSPI_CTRL_TX_DMA_EN_Pos)) /* Assigment of value for TX_DMA_EN in the QMSPI_CTRL register */
#define QMSPI_CTRL_RX_TRANS_EN_Pos            _UINT32_(6)                                          /* (QMSPI_CTRL) This bit enables the receive function of the SPI interface.\n                 1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer\n                 0=Receive is disabled Position */
#define QMSPI_CTRL_RX_TRANS_EN_Msk            (_UINT32_(0x1) << QMSPI_CTRL_RX_TRANS_EN_Pos)        /* (QMSPI_CTRL) This bit enables the receive function of the SPI interface.\n                 1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer\n                 0=Receive is disabled Mask */
#define QMSPI_CTRL_RX_TRANS_EN(value)         (QMSPI_CTRL_RX_TRANS_EN_Msk & (_UINT32_(value) << QMSPI_CTRL_RX_TRANS_EN_Pos)) /* Assigment of value for RX_TRANS_EN in the QMSPI_CTRL register */
#define QMSPI_CTRL_RX_DMA_EN_Pos              _UINT32_(7)                                          /* (QMSPI_CTRL) This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface\n                 reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n                 1=DMA is enabled.and set to 1 Byte\n                 2=DMA is enabled and set to 2 Bytes\n                 3=DMA is enabled and set to 4 Bytes\n                 0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware Position */
#define QMSPI_CTRL_RX_DMA_EN_Msk              (_UINT32_(0x3) << QMSPI_CTRL_RX_DMA_EN_Pos)          /* (QMSPI_CTRL) This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface\n                 reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n                 1=DMA is enabled.and set to 1 Byte\n                 2=DMA is enabled and set to 2 Bytes\n                 3=DMA is enabled and set to 4 Bytes\n                 0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware Mask */
#define QMSPI_CTRL_RX_DMA_EN(value)           (QMSPI_CTRL_RX_DMA_EN_Msk & (_UINT32_(value) << QMSPI_CTRL_RX_DMA_EN_Pos)) /* Assigment of value for RX_DMA_EN in the QMSPI_CTRL register */
#define QMSPI_CTRL_CLOSE_TRANS_EN_Pos         _UINT32_(9)                                          /* (QMSPI_CTRL) This selects what action is taken at the end of a transfer. When the transaction closes, the Chip Select de-asserts, the SPI \n     interface returns to IDLE and the DMA interface terminates When Description Buffers are in use this bit must be set only on the Last Buffer.\n     1=The transaction is terminated\n     0=The transaction is not terminated Position */
#define QMSPI_CTRL_CLOSE_TRANS_EN_Msk         (_UINT32_(0x1) << QMSPI_CTRL_CLOSE_TRANS_EN_Pos)     /* (QMSPI_CTRL) This selects what action is taken at the end of a transfer. When the transaction closes, the Chip Select de-asserts, the SPI \n     interface returns to IDLE and the DMA interface terminates When Description Buffers are in use this bit must be set only on the Last Buffer.\n     1=The transaction is terminated\n     0=The transaction is not terminated Mask */
#define QMSPI_CTRL_CLOSE_TRANS_EN(value)      (QMSPI_CTRL_CLOSE_TRANS_EN_Msk & (_UINT32_(value) << QMSPI_CTRL_CLOSE_TRANS_EN_Pos)) /* Assigment of value for CLOSE_TRANS_EN in the QMSPI_CTRL register */
#define QMSPI_CTRL_TRANS_UNITS_Pos            _UINT32_(10)                                         /* (QMSPI_CTRL) 3=TRANSFER_LENGTH defined in units of 16-byte segments\n     2=TRANSFER_LENGTH defined in units of 4-byte segments\n     1=TRANSFER_LENGTH defined in units of bytes\n     0=TRANSFER_LENGTH defined in units of bits. Position */
#define QMSPI_CTRL_TRANS_UNITS_Msk            (_UINT32_(0x3) << QMSPI_CTRL_TRANS_UNITS_Pos)        /* (QMSPI_CTRL) 3=TRANSFER_LENGTH defined in units of 16-byte segments\n     2=TRANSFER_LENGTH defined in units of 4-byte segments\n     1=TRANSFER_LENGTH defined in units of bytes\n     0=TRANSFER_LENGTH defined in units of bits. Mask */
#define QMSPI_CTRL_TRANS_UNITS(value)         (QMSPI_CTRL_TRANS_UNITS_Msk & (_UINT32_(value) << QMSPI_CTRL_TRANS_UNITS_Pos)) /* Assigment of value for TRANS_UNITS in the QMSPI_CTRL register */
#define QMSPI_CTRL_DESCR_BUFF_PTR_Pos         _UINT32_(12)                                         /* (QMSPI_CTRL) This field selects the first buffer used if Description Buffers are enabled. Position */
#define QMSPI_CTRL_DESCR_BUFF_PTR_Msk         (_UINT32_(0xF) << QMSPI_CTRL_DESCR_BUFF_PTR_Pos)     /* (QMSPI_CTRL) This field selects the first buffer used if Description Buffers are enabled. Mask */
#define QMSPI_CTRL_DESCR_BUFF_PTR(value)      (QMSPI_CTRL_DESCR_BUFF_PTR_Msk & (_UINT32_(value) << QMSPI_CTRL_DESCR_BUFF_PTR_Pos)) /* Assigment of value for DESCR_BUFF_PTR in the QMSPI_CTRL register */
#define QMSPI_CTRL_DESCR_BUFF_EN_Pos          _UINT32_(16)                                         /* (QMSPI_CTRL) This enables the Description Buffers to be used.\n     1=Description Buffers in use. The first buffer is defined in DESCRIPTION_BUFFER_POINTER\n     0=Description Buffers disabled. Position */
#define QMSPI_CTRL_DESCR_BUFF_EN_Msk          (_UINT32_(0x1) << QMSPI_CTRL_DESCR_BUFF_EN_Pos)      /* (QMSPI_CTRL) This enables the Description Buffers to be used.\n     1=Description Buffers in use. The first buffer is defined in DESCRIPTION_BUFFER_POINTER\n     0=Description Buffers disabled. Mask */
#define QMSPI_CTRL_DESCR_BUFF_EN(value)       (QMSPI_CTRL_DESCR_BUFF_EN_Msk & (_UINT32_(value) << QMSPI_CTRL_DESCR_BUFF_EN_Pos)) /* Assigment of value for DESCR_BUFF_EN in the QMSPI_CTRL register */
#define QMSPI_CTRL_TRANS_LEN_Pos              _UINT32_(17)                                         /* (QMSPI_CTRL) The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS.\n     A value of 0 means an infinite length transfer. Position */
#define QMSPI_CTRL_TRANS_LEN_Msk              (_UINT32_(0x7FFF) << QMSPI_CTRL_TRANS_LEN_Pos)       /* (QMSPI_CTRL) The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS.\n     A value of 0 means an infinite length transfer. Mask */
#define QMSPI_CTRL_TRANS_LEN(value)           (QMSPI_CTRL_TRANS_LEN_Msk & (_UINT32_(value) << QMSPI_CTRL_TRANS_LEN_Pos)) /* Assigment of value for TRANS_LEN in the QMSPI_CTRL register */
#define QMSPI_CTRL_Msk                        _UINT32_(0xFFFFFFFF)                                 /* (QMSPI_CTRL) Register Mask  */


/* -------- QMSPI_EXE : (QMSPI Offset: 0x08) (R/W 32) QMSPI Execute Register -------- */
#define QMSPI_EXE_RESETVALUE                  _UINT32_(0x00)                                       /*  (QMSPI_EXE) QMSPI Execute Register  Reset Value */

#define QMSPI_EXE_START_Pos                   _UINT32_(0)                                          /* (QMSPI_EXE) Writing a 1 to this bit will start the SPI transfer. Writing a 0 to this bit has no effect. This bit is self-clearing.\n     This bit must not be set to 1 if the field STOP in this register is set to 1. Position */
#define QMSPI_EXE_START_Msk                   (_UINT32_(0x1) << QMSPI_EXE_START_Pos)               /* (QMSPI_EXE) Writing a 1 to this bit will start the SPI transfer. Writing a 0 to this bit has no effect. This bit is self-clearing.\n     This bit must not be set to 1 if the field STOP in this register is set to 1. Mask */
#define QMSPI_EXE_START(value)                (QMSPI_EXE_START_Msk & (_UINT32_(value) << QMSPI_EXE_START_Pos)) /* Assigment of value for START in the QMSPI_EXE register */
#define QMSPI_EXE_STOP_Pos                    _UINT32_(1)                                          /* (QMSPI_EXE) Writing a 1 to this bit will stop any transfer in progress at the next byte boundary. Writing a 0 to this bit has no effect.\n     This bit is self clearing. This bit must not be set to 1 if the field START in this register is set to 1. Position */
#define QMSPI_EXE_STOP_Msk                    (_UINT32_(0x1) << QMSPI_EXE_STOP_Pos)                /* (QMSPI_EXE) Writing a 1 to this bit will stop any transfer in progress at the next byte boundary. Writing a 0 to this bit has no effect.\n     This bit is self clearing. This bit must not be set to 1 if the field START in this register is set to 1. Mask */
#define QMSPI_EXE_STOP(value)                 (QMSPI_EXE_STOP_Msk & (_UINT32_(value) << QMSPI_EXE_STOP_Pos)) /* Assigment of value for STOP in the QMSPI_EXE register */
#define QMSPI_EXE_CLR_DAT_BUFF_Pos            _UINT32_(2)                                          /* (QMSPI_EXE) Writing a 1 to this bit will clear out the Transmit and Receive FIFOs. Any data stored in the FIFOs is discarded and all count fields are reset.\n     Writing a 0 to this bit has no effect. This bit is self clearing. Position */
#define QMSPI_EXE_CLR_DAT_BUFF_Msk            (_UINT32_(0x1) << QMSPI_EXE_CLR_DAT_BUFF_Pos)        /* (QMSPI_EXE) Writing a 1 to this bit will clear out the Transmit and Receive FIFOs. Any data stored in the FIFOs is discarded and all count fields are reset.\n     Writing a 0 to this bit has no effect. This bit is self clearing. Mask */
#define QMSPI_EXE_CLR_DAT_BUFF(value)         (QMSPI_EXE_CLR_DAT_BUFF_Msk & (_UINT32_(value) << QMSPI_EXE_CLR_DAT_BUFF_Pos)) /* Assigment of value for CLR_DAT_BUFF in the QMSPI_EXE register */
#define QMSPI_EXE_Msk                         _UINT32_(0x00000007)                                 /* (QMSPI_EXE) Register Mask  */


/* -------- QMSPI_IFCTRL : (QMSPI Offset: 0x0C) (R/W 32) QMSPI Interface Control Register -------- */
#define QMSPI_IFCTRL_RESETVALUE               _UINT32_(0x00)                                       /*  (QMSPI_IFCTRL) QMSPI Interface Control Register  Reset Value */

#define QMSPI_IFCTRL_WR_PRCT_OUT_VAL_Pos      _UINT32_(0)                                          /* (QMSPI_IFCTRL) This bit sets the value on the WRITE PROTECT SPI Output Port if it is driven.\n                 1=WRITE PROTECT is driven to 1; 0=WRITE PROTECT is driven to 0 Position */
#define QMSPI_IFCTRL_WR_PRCT_OUT_VAL_Msk      (_UINT32_(0x1) << QMSPI_IFCTRL_WR_PRCT_OUT_VAL_Pos)  /* (QMSPI_IFCTRL) This bit sets the value on the WRITE PROTECT SPI Output Port if it is driven.\n                 1=WRITE PROTECT is driven to 1; 0=WRITE PROTECT is driven to 0 Mask */
#define QMSPI_IFCTRL_WR_PRCT_OUT_VAL(value)   (QMSPI_IFCTRL_WR_PRCT_OUT_VAL_Msk & (_UINT32_(value) << QMSPI_IFCTRL_WR_PRCT_OUT_VAL_Pos)) /* Assigment of value for WR_PRCT_OUT_VAL in the QMSPI_IFCTRL register */
#define QMSPI_IFCTRL_WR_PRCT_OUT_EN_Pos       _UINT32_(1)                                          /* (QMSPI_IFCTRL) 1=WRITE PROTECT SPI Output Port is driven\n                 0=WRITE PROTECT SPI Output Port is not driven Position */
#define QMSPI_IFCTRL_WR_PRCT_OUT_EN_Msk       (_UINT32_(0x1) << QMSPI_IFCTRL_WR_PRCT_OUT_EN_Pos)   /* (QMSPI_IFCTRL) 1=WRITE PROTECT SPI Output Port is driven\n                 0=WRITE PROTECT SPI Output Port is not driven Mask */
#define QMSPI_IFCTRL_WR_PRCT_OUT_EN(value)    (QMSPI_IFCTRL_WR_PRCT_OUT_EN_Msk & (_UINT32_(value) << QMSPI_IFCTRL_WR_PRCT_OUT_EN_Pos)) /* Assigment of value for WR_PRCT_OUT_EN in the QMSPI_IFCTRL register */
#define QMSPI_IFCTRL_HLD_OUT_VAL_Pos          _UINT32_(2)                                          /* (QMSPI_IFCTRL) This bit sets the value on the HOLD SPI Output Port if it is driven.\n                 1=HOLD is driven to 1; 0=HOLD is driven to 0. Position */
#define QMSPI_IFCTRL_HLD_OUT_VAL_Msk          (_UINT32_(0x1) << QMSPI_IFCTRL_HLD_OUT_VAL_Pos)      /* (QMSPI_IFCTRL) This bit sets the value on the HOLD SPI Output Port if it is driven.\n                 1=HOLD is driven to 1; 0=HOLD is driven to 0. Mask */
#define QMSPI_IFCTRL_HLD_OUT_VAL(value)       (QMSPI_IFCTRL_HLD_OUT_VAL_Msk & (_UINT32_(value) << QMSPI_IFCTRL_HLD_OUT_VAL_Pos)) /* Assigment of value for HLD_OUT_VAL in the QMSPI_IFCTRL register */
#define QMSPI_IFCTRL_HLD_OUT_EN_Pos           _UINT32_(3)                                          /* (QMSPI_IFCTRL) 1=HOLD SPI Output Port is driven\n                 0=HOLD SPI Output Port is not driven. Position */
#define QMSPI_IFCTRL_HLD_OUT_EN_Msk           (_UINT32_(0x1) << QMSPI_IFCTRL_HLD_OUT_EN_Pos)       /* (QMSPI_IFCTRL) 1=HOLD SPI Output Port is driven\n                 0=HOLD SPI Output Port is not driven. Mask */
#define QMSPI_IFCTRL_HLD_OUT_EN(value)        (QMSPI_IFCTRL_HLD_OUT_EN_Msk & (_UINT32_(value) << QMSPI_IFCTRL_HLD_OUT_EN_Pos)) /* Assigment of value for HLD_OUT_EN in the QMSPI_IFCTRL register */
#define QMSPI_IFCTRL_PD_ON_NOT_SEL_Pos        _UINT32_(4)                                          /* (QMSPI_IFCTRL) 1=Enable pull-down resistors on Receive pins while the SPI Chip Select signal is not asserted\n     0=No pull-down resistors enabled on Receive pins Position */
#define QMSPI_IFCTRL_PD_ON_NOT_SEL_Msk        (_UINT32_(0x1) << QMSPI_IFCTRL_PD_ON_NOT_SEL_Pos)    /* (QMSPI_IFCTRL) 1=Enable pull-down resistors on Receive pins while the SPI Chip Select signal is not asserted\n     0=No pull-down resistors enabled on Receive pins Mask */
#define QMSPI_IFCTRL_PD_ON_NOT_SEL(value)     (QMSPI_IFCTRL_PD_ON_NOT_SEL_Msk & (_UINT32_(value) << QMSPI_IFCTRL_PD_ON_NOT_SEL_Pos)) /* Assigment of value for PD_ON_NOT_SEL in the QMSPI_IFCTRL register */
#define QMSPI_IFCTRL_PU_ON_NOTSEL_Pos         _UINT32_(5)                                          /* (QMSPI_IFCTRL) 1=Enable pull-up resistors on Receive pins while the SPI Chip Select signal is not asserted\n     0=No pull-up resistors enabled on Receive pins. Position */
#define QMSPI_IFCTRL_PU_ON_NOTSEL_Msk         (_UINT32_(0x1) << QMSPI_IFCTRL_PU_ON_NOTSEL_Pos)     /* (QMSPI_IFCTRL) 1=Enable pull-up resistors on Receive pins while the SPI Chip Select signal is not asserted\n     0=No pull-up resistors enabled on Receive pins. Mask */
#define QMSPI_IFCTRL_PU_ON_NOTSEL(value)      (QMSPI_IFCTRL_PU_ON_NOTSEL_Msk & (_UINT32_(value) << QMSPI_IFCTRL_PU_ON_NOTSEL_Pos)) /* Assigment of value for PU_ON_NOTSEL in the QMSPI_IFCTRL register */
#define QMSPI_IFCTRL_PD_ON_NOTDRIVEN_Pos      _UINT32_(6)                                          /* (QMSPI_IFCTRL) 1=Enable pull-down resistors on Transmit pins while the pins are not driven\n     0=No pull-down resistors enabled ion Transmit pins. Position */
#define QMSPI_IFCTRL_PD_ON_NOTDRIVEN_Msk      (_UINT32_(0x1) << QMSPI_IFCTRL_PD_ON_NOTDRIVEN_Pos)  /* (QMSPI_IFCTRL) 1=Enable pull-down resistors on Transmit pins while the pins are not driven\n     0=No pull-down resistors enabled ion Transmit pins. Mask */
#define QMSPI_IFCTRL_PD_ON_NOTDRIVEN(value)   (QMSPI_IFCTRL_PD_ON_NOTDRIVEN_Msk & (_UINT32_(value) << QMSPI_IFCTRL_PD_ON_NOTDRIVEN_Pos)) /* Assigment of value for PD_ON_NOTDRIVEN in the QMSPI_IFCTRL register */
#define QMSPI_IFCTRL_PU_ON_NOTDRIVEN_Pos      _UINT32_(7)                                          /* (QMSPI_IFCTRL) 1=Enable pull-up resistors on Transmit pins while the pins are not driven\n     0=No pull-up resistors enabled ion Transmit pins. Position */
#define QMSPI_IFCTRL_PU_ON_NOTDRIVEN_Msk      (_UINT32_(0x1) << QMSPI_IFCTRL_PU_ON_NOTDRIVEN_Pos)  /* (QMSPI_IFCTRL) 1=Enable pull-up resistors on Transmit pins while the pins are not driven\n     0=No pull-up resistors enabled ion Transmit pins. Mask */
#define QMSPI_IFCTRL_PU_ON_NOTDRIVEN(value)   (QMSPI_IFCTRL_PU_ON_NOTDRIVEN_Msk & (_UINT32_(value) << QMSPI_IFCTRL_PU_ON_NOTDRIVEN_Pos)) /* Assigment of value for PU_ON_NOTDRIVEN in the QMSPI_IFCTRL register */
#define QMSPI_IFCTRL_Msk                      _UINT32_(0x000000FF)                                 /* (QMSPI_IFCTRL) Register Mask  */


/* -------- QMSPI_STS : (QMSPI Offset: 0x10) (R/W 32) QMSPI Status Register -------- */
#define QMSPI_STS_RESETVALUE                  _UINT32_(0x2200)                                     /*  (QMSPI_STS) QMSPI Status Register  Reset Value */

#define QMSPI_STS_TRANS_COMPL_Pos             _UINT32_(0)                                          /* (QMSPI_STS) In Manual Mode (neither DMA nor Description Buffers are enabled), this bit will be set to 1 when the transfer matches TRANSFER_LENGTH.\n                 If DMA Mode is enabled, this bit will be set to 1 when DMA_COMPLETE is set to 1. In Description Buffer Mode, this bit will be set to 1 only when the Last Buffer completes its transfer.\n     In all cases, this bit will be set to 1 if the STOP bit is set to 1 and the controller has completed the current 8 bits being copied.\n                 1=Transfer completed; 0=Transfer not complete. Position */
#define QMSPI_STS_TRANS_COMPL_Msk             (_UINT32_(0x1) << QMSPI_STS_TRANS_COMPL_Pos)         /* (QMSPI_STS) In Manual Mode (neither DMA nor Description Buffers are enabled), this bit will be set to 1 when the transfer matches TRANSFER_LENGTH.\n                 If DMA Mode is enabled, this bit will be set to 1 when DMA_COMPLETE is set to 1. In Description Buffer Mode, this bit will be set to 1 only when the Last Buffer completes its transfer.\n     In all cases, this bit will be set to 1 if the STOP bit is set to 1 and the controller has completed the current 8 bits being copied.\n                 1=Transfer completed; 0=Transfer not complete. Mask */
#define QMSPI_STS_TRANS_COMPL(value)          (QMSPI_STS_TRANS_COMPL_Msk & (_UINT32_(value) << QMSPI_STS_TRANS_COMPL_Pos)) /* Assigment of value for TRANS_COMPL in the QMSPI_STS register */
#define QMSPI_STS_DMA_COMPL_Pos               _UINT32_(1)                                          /* (QMSPI_STS) This field has no meaning if DMA is not enabled. This bit will be set to 1 when the DMA controller asserts the DONE signal to the SPI controller.\n     This occurs either when the SPI controller has closed the DMA transfer, or the DMA channel has completed its count. If both Transmit and Receive DMA transfers are\n      active, then this bit will only assert after both have completed. If CLOSE_TRANSFER_ENABLE is enabled, DMA_COMPLETE and TRANSFER_COMPLETE will be asserted simultaneously.\n     This status is not inhibited by the description buffers, so it can fire on all valid description buffers while operating in that mode.\n                 1=DMA completed; 0=DMA not completed. Position */
#define QMSPI_STS_DMA_COMPL_Msk               (_UINT32_(0x1) << QMSPI_STS_DMA_COMPL_Pos)           /* (QMSPI_STS) This field has no meaning if DMA is not enabled. This bit will be set to 1 when the DMA controller asserts the DONE signal to the SPI controller.\n     This occurs either when the SPI controller has closed the DMA transfer, or the DMA channel has completed its count. If both Transmit and Receive DMA transfers are\n      active, then this bit will only assert after both have completed. If CLOSE_TRANSFER_ENABLE is enabled, DMA_COMPLETE and TRANSFER_COMPLETE will be asserted simultaneously.\n     This status is not inhibited by the description buffers, so it can fire on all valid description buffers while operating in that mode.\n                 1=DMA completed; 0=DMA not completed. Mask */
#define QMSPI_STS_DMA_COMPL(value)            (QMSPI_STS_DMA_COMPL_Msk & (_UINT32_(value) << QMSPI_STS_DMA_COMPL_Pos)) /* Assigment of value for DMA_COMPL in the QMSPI_STS register */
#define QMSPI_STS_TX_BUFF_ERR_Pos             _UINT32_(2)                                          /* (QMSPI_STS) 1=Overflow error occurred (attempt to write to a full Transmit Buffer)\n                 0=No overflow occurred. Position */
#define QMSPI_STS_TX_BUFF_ERR_Msk             (_UINT32_(0x1) << QMSPI_STS_TX_BUFF_ERR_Pos)         /* (QMSPI_STS) 1=Overflow error occurred (attempt to write to a full Transmit Buffer)\n                 0=No overflow occurred. Mask */
#define QMSPI_STS_TX_BUFF_ERR(value)          (QMSPI_STS_TX_BUFF_ERR_Msk & (_UINT32_(value) << QMSPI_STS_TX_BUFF_ERR_Pos)) /* Assigment of value for TX_BUFF_ERR in the QMSPI_STS register */
#define QMSPI_STS_RX_BUFF_ERR_Pos             _UINT32_(3)                                          /* (QMSPI_STS) 1=Underflow error occurred (attempt to read from an empty Receive Buffer)\n                 0=No underflow occurred. Position */
#define QMSPI_STS_RX_BUFF_ERR_Msk             (_UINT32_(0x1) << QMSPI_STS_RX_BUFF_ERR_Pos)         /* (QMSPI_STS) 1=Underflow error occurred (attempt to read from an empty Receive Buffer)\n                 0=No underflow occurred. Mask */
#define QMSPI_STS_RX_BUFF_ERR(value)          (QMSPI_STS_RX_BUFF_ERR_Msk & (_UINT32_(value) << QMSPI_STS_RX_BUFF_ERR_Pos)) /* Assigment of value for RX_BUFF_ERR in the QMSPI_STS register */
#define QMSPI_STS_PRGM_ERR_Pos                _UINT32_(4)                                          /* (QMSPI_STS) This bit if a programming error is detected.\n     1=Programming Error detected; 0=No programming error detected. Position */
#define QMSPI_STS_PRGM_ERR_Msk                (_UINT32_(0x1) << QMSPI_STS_PRGM_ERR_Pos)            /* (QMSPI_STS) This bit if a programming error is detected.\n     1=Programming Error detected; 0=No programming error detected. Mask */
#define QMSPI_STS_PRGM_ERR(value)             (QMSPI_STS_PRGM_ERR_Msk & (_UINT32_(value) << QMSPI_STS_PRGM_ERR_Pos)) /* Assigment of value for PRGM_ERR in the QMSPI_STS register */
#define QMSPI_STS_TX_BUFF_FULL_Pos            _UINT32_(8)                                          /* (QMSPI_STS) 1=The Transmit Buffer is full\n     0=The Transmit Buffer is not full. Position */
#define QMSPI_STS_TX_BUFF_FULL_Msk            (_UINT32_(0x1) << QMSPI_STS_TX_BUFF_FULL_Pos)        /* (QMSPI_STS) 1=The Transmit Buffer is full\n     0=The Transmit Buffer is not full. Mask */
#define QMSPI_STS_TX_BUFF_FULL(value)         (QMSPI_STS_TX_BUFF_FULL_Msk & (_UINT32_(value) << QMSPI_STS_TX_BUFF_FULL_Pos)) /* Assigment of value for TX_BUFF_FULL in the QMSPI_STS register */
#define QMSPI_STS_TX_BUFF_EMP_Pos             _UINT32_(9)                                          /* (QMSPI_STS) 1=The Transmit Buffer is empty\n     0=The Transmit Buffer is not empty. Position */
#define QMSPI_STS_TX_BUFF_EMP_Msk             (_UINT32_(0x1) << QMSPI_STS_TX_BUFF_EMP_Pos)         /* (QMSPI_STS) 1=The Transmit Buffer is empty\n     0=The Transmit Buffer is not empty. Mask */
#define QMSPI_STS_TX_BUFF_EMP(value)          (QMSPI_STS_TX_BUFF_EMP_Msk & (_UINT32_(value) << QMSPI_STS_TX_BUFF_EMP_Pos)) /* Assigment of value for TX_BUFF_EMP in the QMSPI_STS register */
#define QMSPI_STS_TX_BUFF_REQ_Pos             _UINT32_(10)                                         /* (QMSPI_STS) This status is asserted if the Transmit Buffer reaches a high water mark established by the TRANSMIT_BUFFER_TRIGGER field.\n     1=TRANSMIT_BUFFER_COUNT is less than or equal to TRANSMIT_BUFFER_TRIGGER; 0=TRANSMIT_BUFFER_COUNT is greater than TRANSMIT_BUFFER_TRIGGER. Position */
#define QMSPI_STS_TX_BUFF_REQ_Msk             (_UINT32_(0x1) << QMSPI_STS_TX_BUFF_REQ_Pos)         /* (QMSPI_STS) This status is asserted if the Transmit Buffer reaches a high water mark established by the TRANSMIT_BUFFER_TRIGGER field.\n     1=TRANSMIT_BUFFER_COUNT is less than or equal to TRANSMIT_BUFFER_TRIGGER; 0=TRANSMIT_BUFFER_COUNT is greater than TRANSMIT_BUFFER_TRIGGER. Mask */
#define QMSPI_STS_TX_BUFF_REQ(value)          (QMSPI_STS_TX_BUFF_REQ_Msk & (_UINT32_(value) << QMSPI_STS_TX_BUFF_REQ_Pos)) /* Assigment of value for TX_BUFF_REQ in the QMSPI_STS register */
#define QMSPI_STS_TX_BUFF_STALL_Pos           _UINT32_(11)                                         /* (QMSPI_STS) 1=The SPI interface had been stalled due to a flow issue (an attempt by the interface to read from an empty Transmit Buffer)\n     0=No stalls occurred. Position */
#define QMSPI_STS_TX_BUFF_STALL_Msk           (_UINT32_(0x1) << QMSPI_STS_TX_BUFF_STALL_Pos)       /* (QMSPI_STS) 1=The SPI interface had been stalled due to a flow issue (an attempt by the interface to read from an empty Transmit Buffer)\n     0=No stalls occurred. Mask */
#define QMSPI_STS_TX_BUFF_STALL(value)        (QMSPI_STS_TX_BUFF_STALL_Msk & (_UINT32_(value) << QMSPI_STS_TX_BUFF_STALL_Pos)) /* Assigment of value for TX_BUFF_STALL in the QMSPI_STS register */
#define QMSPI_STS_RX_BUFF_FULL_Pos            _UINT32_(12)                                         /* (QMSPI_STS) 1=The Receive Buffer is full\n     0=The Receive Buffer is not full. Position */
#define QMSPI_STS_RX_BUFF_FULL_Msk            (_UINT32_(0x1) << QMSPI_STS_RX_BUFF_FULL_Pos)        /* (QMSPI_STS) 1=The Receive Buffer is full\n     0=The Receive Buffer is not full. Mask */
#define QMSPI_STS_RX_BUFF_FULL(value)         (QMSPI_STS_RX_BUFF_FULL_Msk & (_UINT32_(value) << QMSPI_STS_RX_BUFF_FULL_Pos)) /* Assigment of value for RX_BUFF_FULL in the QMSPI_STS register */
#define QMSPI_STS_RX_BUFF_EMP_Pos             _UINT32_(13)                                         /* (QMSPI_STS) 1=The Receive Buffer is empty\n     0=The Receive Buffer is not empty. Position */
#define QMSPI_STS_RX_BUFF_EMP_Msk             (_UINT32_(0x1) << QMSPI_STS_RX_BUFF_EMP_Pos)         /* (QMSPI_STS) 1=The Receive Buffer is empty\n     0=The Receive Buffer is not empty. Mask */
#define QMSPI_STS_RX_BUFF_EMP(value)          (QMSPI_STS_RX_BUFF_EMP_Msk & (_UINT32_(value) << QMSPI_STS_RX_BUFF_EMP_Pos)) /* Assigment of value for RX_BUFF_EMP in the QMSPI_STS register */
#define QMSPI_STS_RX_BUFF_REQ_Pos             _UINT32_(14)                                         /* (QMSPI_STS) This status is asserted if the Receive Buffer reaches a high water mark established by the RECEIVE_BUFFER_TRIGGER field.\n                 1=RECEIVE_BUFFER_COUNT is greater than or equal to RECEIVE_BUFFER_TRIGGER\n                 0=RECEIVE_BUFFER_COUNT is less than RECEIVE_BUFFER_TRIGGER. Position */
#define QMSPI_STS_RX_BUFF_REQ_Msk             (_UINT32_(0x1) << QMSPI_STS_RX_BUFF_REQ_Pos)         /* (QMSPI_STS) This status is asserted if the Receive Buffer reaches a high water mark established by the RECEIVE_BUFFER_TRIGGER field.\n                 1=RECEIVE_BUFFER_COUNT is greater than or equal to RECEIVE_BUFFER_TRIGGER\n                 0=RECEIVE_BUFFER_COUNT is less than RECEIVE_BUFFER_TRIGGER. Mask */
#define QMSPI_STS_RX_BUFF_REQ(value)          (QMSPI_STS_RX_BUFF_REQ_Msk & (_UINT32_(value) << QMSPI_STS_RX_BUFF_REQ_Pos)) /* Assigment of value for RX_BUFF_REQ in the QMSPI_STS register */
#define QMSPI_STS_RX_BUFF_STALL_Pos           _UINT32_(15)                                         /* (QMSPI_STS) 1=The SPI interface had been stalled due to a flow issue (an attempt by the interface to write to a full Receive Buffer)\n     0=No stalls occurred. Position */
#define QMSPI_STS_RX_BUFF_STALL_Msk           (_UINT32_(0x1) << QMSPI_STS_RX_BUFF_STALL_Pos)       /* (QMSPI_STS) 1=The SPI interface had been stalled due to a flow issue (an attempt by the interface to write to a full Receive Buffer)\n     0=No stalls occurred. Mask */
#define QMSPI_STS_RX_BUFF_STALL(value)        (QMSPI_STS_RX_BUFF_STALL_Msk & (_UINT32_(value) << QMSPI_STS_RX_BUFF_STALL_Pos)) /* Assigment of value for RX_BUFF_STALL in the QMSPI_STS register */
#define QMSPI_STS_TRANS_ACTIV_Pos             _UINT32_(16)                                         /* (QMSPI_STS) 1=A transfer is currently executing\n     0=No transfer currently in progress. Position */
#define QMSPI_STS_TRANS_ACTIV_Msk             (_UINT32_(0x1) << QMSPI_STS_TRANS_ACTIV_Pos)         /* (QMSPI_STS) 1=A transfer is currently executing\n     0=No transfer currently in progress. Mask */
#define QMSPI_STS_TRANS_ACTIV(value)          (QMSPI_STS_TRANS_ACTIV_Msk & (_UINT32_(value) << QMSPI_STS_TRANS_ACTIV_Pos)) /* Assigment of value for TRANS_ACTIV in the QMSPI_STS register */
#define QMSPI_STS_CUR_DESCR_BUF_Pos           _UINT32_(24)                                         /* (QMSPI_STS) This field shows the Description Buffer currently active. This field has no meaning if Description Buffers are not enabled. Position */
#define QMSPI_STS_CUR_DESCR_BUF_Msk           (_UINT32_(0xF) << QMSPI_STS_CUR_DESCR_BUF_Pos)       /* (QMSPI_STS) This field shows the Description Buffer currently active. This field has no meaning if Description Buffers are not enabled. Mask */
#define QMSPI_STS_CUR_DESCR_BUF(value)        (QMSPI_STS_CUR_DESCR_BUF_Msk & (_UINT32_(value) << QMSPI_STS_CUR_DESCR_BUF_Pos)) /* Assigment of value for CUR_DESCR_BUF in the QMSPI_STS register */
#define QMSPI_STS_Msk                         _UINT32_(0x0F01FF1F)                                 /* (QMSPI_STS) Register Mask  */


/* -------- QMSPI_BUF_CNT_STS : (QMSPI Offset: 0x14) (R/W 32) QMSPI Buffer Count Status Register -------- */
#define QMSPI_BUF_CNT_STS_RESETVALUE          _UINT32_(0x00)                                       /*  (QMSPI_BUF_CNT_STS) QMSPI Buffer Count Status Register  Reset Value */

#define QMSPI_BUF_CNT_STS_TX_BUFF_CNT_Pos     _UINT32_(0)                                          /* (QMSPI_BUF_CNT_STS) This is a count of the number of bytes currently valid in the Transmit Buffer. Position */
#define QMSPI_BUF_CNT_STS_TX_BUFF_CNT_Msk     (_UINT32_(0xFFFF) << QMSPI_BUF_CNT_STS_TX_BUFF_CNT_Pos) /* (QMSPI_BUF_CNT_STS) This is a count of the number of bytes currently valid in the Transmit Buffer. Mask */
#define QMSPI_BUF_CNT_STS_TX_BUFF_CNT(value)  (QMSPI_BUF_CNT_STS_TX_BUFF_CNT_Msk & (_UINT32_(value) << QMSPI_BUF_CNT_STS_TX_BUFF_CNT_Pos)) /* Assigment of value for TX_BUFF_CNT in the QMSPI_BUF_CNT_STS register */
#define QMSPI_BUF_CNT_STS_RX_BUFF_CNT_Pos     _UINT32_(16)                                         /* (QMSPI_BUF_CNT_STS) This is a count of the number of bytes currently valid in the Receive Buffer. Position */
#define QMSPI_BUF_CNT_STS_RX_BUFF_CNT_Msk     (_UINT32_(0xFFFF) << QMSPI_BUF_CNT_STS_RX_BUFF_CNT_Pos) /* (QMSPI_BUF_CNT_STS) This is a count of the number of bytes currently valid in the Receive Buffer. Mask */
#define QMSPI_BUF_CNT_STS_RX_BUFF_CNT(value)  (QMSPI_BUF_CNT_STS_RX_BUFF_CNT_Msk & (_UINT32_(value) << QMSPI_BUF_CNT_STS_RX_BUFF_CNT_Pos)) /* Assigment of value for RX_BUFF_CNT in the QMSPI_BUF_CNT_STS register */
#define QMSPI_BUF_CNT_STS_Msk                 _UINT32_(0xFFFFFFFF)                                 /* (QMSPI_BUF_CNT_STS) Register Mask  */


/* -------- QMSPI_IEN : (QMSPI Offset: 0x18) (R/W 32) QMSPI Interrupt Enable Register -------- */
#define QMSPI_IEN_RESETVALUE                  _UINT32_(0x2000)                                     /*  (QMSPI_IEN) QMSPI Interrupt Enable Register  Reset Value */

#define QMSPI_IEN_TRANS_COMPL_EN_Pos          _UINT32_(0)                                          /* (QMSPI_IEN) 1=Enable an interrupt if TRANSFER_COMPLETE is asserted\n     0=Disable the interrupt. Position */
#define QMSPI_IEN_TRANS_COMPL_EN_Msk          (_UINT32_(0x1) << QMSPI_IEN_TRANS_COMPL_EN_Pos)      /* (QMSPI_IEN) 1=Enable an interrupt if TRANSFER_COMPLETE is asserted\n     0=Disable the interrupt. Mask */
#define QMSPI_IEN_TRANS_COMPL_EN(value)       (QMSPI_IEN_TRANS_COMPL_EN_Msk & (_UINT32_(value) << QMSPI_IEN_TRANS_COMPL_EN_Pos)) /* Assigment of value for TRANS_COMPL_EN in the QMSPI_IEN register */
#define QMSPI_IEN_DMA_COMPL_EN_Pos            _UINT32_(1)                                          /* (QMSPI_IEN) 1=Enable an interrupt if DMA_COMPLETE is asserted\n     0=Disable the interrupt. Position */
#define QMSPI_IEN_DMA_COMPL_EN_Msk            (_UINT32_(0x1) << QMSPI_IEN_DMA_COMPL_EN_Pos)        /* (QMSPI_IEN) 1=Enable an interrupt if DMA_COMPLETE is asserted\n     0=Disable the interrupt. Mask */
#define QMSPI_IEN_DMA_COMPL_EN(value)         (QMSPI_IEN_DMA_COMPL_EN_Msk & (_UINT32_(value) << QMSPI_IEN_DMA_COMPL_EN_Pos)) /* Assigment of value for DMA_COMPL_EN in the QMSPI_IEN register */
#define QMSPI_IEN_TX_BUF_ERR_EN_Pos           _UINT32_(2)                                          /* (QMSPI_IEN) 1=Enable an interrupt if TRANSMIT_BUFFER_ERROR is asserted\n     0=Disable the interrupt. Position */
#define QMSPI_IEN_TX_BUF_ERR_EN_Msk           (_UINT32_(0x1) << QMSPI_IEN_TX_BUF_ERR_EN_Pos)       /* (QMSPI_IEN) 1=Enable an interrupt if TRANSMIT_BUFFER_ERROR is asserted\n     0=Disable the interrupt. Mask */
#define QMSPI_IEN_TX_BUF_ERR_EN(value)        (QMSPI_IEN_TX_BUF_ERR_EN_Msk & (_UINT32_(value) << QMSPI_IEN_TX_BUF_ERR_EN_Pos)) /* Assigment of value for TX_BUF_ERR_EN in the QMSPI_IEN register */
#define QMSPI_IEN_RX_BUF_ERR_EN_Pos           _UINT32_(3)                                          /* (QMSPI_IEN) 1=Enable an interrupt if RECEIVE_BUFFER_ERROR is asserted\n     0=Disable the interrupt. Position */
#define QMSPI_IEN_RX_BUF_ERR_EN_Msk           (_UINT32_(0x1) << QMSPI_IEN_RX_BUF_ERR_EN_Pos)       /* (QMSPI_IEN) 1=Enable an interrupt if RECEIVE_BUFFER_ERROR is asserted\n     0=Disable the interrupt. Mask */
#define QMSPI_IEN_RX_BUF_ERR_EN(value)        (QMSPI_IEN_RX_BUF_ERR_EN_Msk & (_UINT32_(value) << QMSPI_IEN_RX_BUF_ERR_EN_Pos)) /* Assigment of value for RX_BUF_ERR_EN in the QMSPI_IEN register */
#define QMSPI_IEN_PRGM_ERR_EN_Pos             _UINT32_(4)                                          /* (QMSPI_IEN) 1=Enable an interrupt if PROGRAMMING_ERROR is asserted\n     0=Disable the interrupt. Position */
#define QMSPI_IEN_PRGM_ERR_EN_Msk             (_UINT32_(0x1) << QMSPI_IEN_PRGM_ERR_EN_Pos)         /* (QMSPI_IEN) 1=Enable an interrupt if PROGRAMMING_ERROR is asserted\n     0=Disable the interrupt. Mask */
#define QMSPI_IEN_PRGM_ERR_EN(value)          (QMSPI_IEN_PRGM_ERR_EN_Msk & (_UINT32_(value) << QMSPI_IEN_PRGM_ERR_EN_Pos)) /* Assigment of value for PRGM_ERR_EN in the QMSPI_IEN register */
#define QMSPI_IEN_TX_BUF_FULL_EN_Pos          _UINT32_(8)                                          /* (QMSPI_IEN) 1=Enable an interrupt if TRANSMIT_BUFFER_FULL is asserted\n     0=Disable the interrupt. Position */
#define QMSPI_IEN_TX_BUF_FULL_EN_Msk          (_UINT32_(0x1) << QMSPI_IEN_TX_BUF_FULL_EN_Pos)      /* (QMSPI_IEN) 1=Enable an interrupt if TRANSMIT_BUFFER_FULL is asserted\n     0=Disable the interrupt. Mask */
#define QMSPI_IEN_TX_BUF_FULL_EN(value)       (QMSPI_IEN_TX_BUF_FULL_EN_Msk & (_UINT32_(value) << QMSPI_IEN_TX_BUF_FULL_EN_Pos)) /* Assigment of value for TX_BUF_FULL_EN in the QMSPI_IEN register */
#define QMSPI_IEN_TX_BUF_EMPTY_EN_Pos         _UINT32_(9)                                          /* (QMSPI_IEN) 1=Enable an interrupt if TRANSMIT_BUFFER_EMPTY is asserted\n     0=Disable the interrupt. Position */
#define QMSPI_IEN_TX_BUF_EMPTY_EN_Msk         (_UINT32_(0x1) << QMSPI_IEN_TX_BUF_EMPTY_EN_Pos)     /* (QMSPI_IEN) 1=Enable an interrupt if TRANSMIT_BUFFER_EMPTY is asserted\n     0=Disable the interrupt. Mask */
#define QMSPI_IEN_TX_BUF_EMPTY_EN(value)      (QMSPI_IEN_TX_BUF_EMPTY_EN_Msk & (_UINT32_(value) << QMSPI_IEN_TX_BUF_EMPTY_EN_Pos)) /* Assigment of value for TX_BUF_EMPTY_EN in the QMSPI_IEN register */
#define QMSPI_IEN_TX_BUF_REQ_EN_Pos           _UINT32_(10)                                         /* (QMSPI_IEN) 1=Enable an interrupt if TRANSMIT_BUFFER_REQUEST is asserted\n     0=Disable the interrupt. Position */
#define QMSPI_IEN_TX_BUF_REQ_EN_Msk           (_UINT32_(0x1) << QMSPI_IEN_TX_BUF_REQ_EN_Pos)       /* (QMSPI_IEN) 1=Enable an interrupt if TRANSMIT_BUFFER_REQUEST is asserted\n     0=Disable the interrupt. Mask */
#define QMSPI_IEN_TX_BUF_REQ_EN(value)        (QMSPI_IEN_TX_BUF_REQ_EN_Msk & (_UINT32_(value) << QMSPI_IEN_TX_BUF_REQ_EN_Pos)) /* Assigment of value for TX_BUF_REQ_EN in the QMSPI_IEN register */
#define QMSPI_IEN_RX_BUF_FUL_EN_Pos           _UINT32_(12)                                         /* (QMSPI_IEN) 1=Enable an interrupt if RECEIVE_BUFFER_FULL is asserted\n     0=Disable the interrupt. Position */
#define QMSPI_IEN_RX_BUF_FUL_EN_Msk           (_UINT32_(0x1) << QMSPI_IEN_RX_BUF_FUL_EN_Pos)       /* (QMSPI_IEN) 1=Enable an interrupt if RECEIVE_BUFFER_FULL is asserted\n     0=Disable the interrupt. Mask */
#define QMSPI_IEN_RX_BUF_FUL_EN(value)        (QMSPI_IEN_RX_BUF_FUL_EN_Msk & (_UINT32_(value) << QMSPI_IEN_RX_BUF_FUL_EN_Pos)) /* Assigment of value for RX_BUF_FUL_EN in the QMSPI_IEN register */
#define QMSPI_IEN_RX_BUF_EMPTY_EN_Pos         _UINT32_(13)                                         /* (QMSPI_IEN) 1=Enable an interrupt if RECEIVE_BUFFER_EMPTY is asserted\n     0=Disable the interrupt. Position */
#define QMSPI_IEN_RX_BUF_EMPTY_EN_Msk         (_UINT32_(0x1) << QMSPI_IEN_RX_BUF_EMPTY_EN_Pos)     /* (QMSPI_IEN) 1=Enable an interrupt if RECEIVE_BUFFER_EMPTY is asserted\n     0=Disable the interrupt. Mask */
#define QMSPI_IEN_RX_BUF_EMPTY_EN(value)      (QMSPI_IEN_RX_BUF_EMPTY_EN_Msk & (_UINT32_(value) << QMSPI_IEN_RX_BUF_EMPTY_EN_Pos)) /* Assigment of value for RX_BUF_EMPTY_EN in the QMSPI_IEN register */
#define QMSPI_IEN_RX_BUF_REQ_EN_Pos           _UINT32_(14)                                         /* (QMSPI_IEN) 1=Enable an interrupt if RECEIVE_BUFFER_REQUEST is asserted\n     0=Disable the interrupt. Position */
#define QMSPI_IEN_RX_BUF_REQ_EN_Msk           (_UINT32_(0x1) << QMSPI_IEN_RX_BUF_REQ_EN_Pos)       /* (QMSPI_IEN) 1=Enable an interrupt if RECEIVE_BUFFER_REQUEST is asserted\n     0=Disable the interrupt. Mask */
#define QMSPI_IEN_RX_BUF_REQ_EN(value)        (QMSPI_IEN_RX_BUF_REQ_EN_Msk & (_UINT32_(value) << QMSPI_IEN_RX_BUF_REQ_EN_Pos)) /* Assigment of value for RX_BUF_REQ_EN in the QMSPI_IEN register */
#define QMSPI_IEN_Msk                         _UINT32_(0x0000771F)                                 /* (QMSPI_IEN) Register Mask  */


/* -------- QMSPI_BUF_CNT_TRIG : (QMSPI Offset: 0x1C) (R/W 32) QMSPI Buffer Count Trigger Register -------- */
#define QMSPI_BUF_CNT_TRIG_RESETVALUE         _UINT32_(0x00)                                       /*  (QMSPI_BUF_CNT_TRIG) QMSPI Buffer Count Trigger Register  Reset Value */

#define QMSPI_BUF_CNT_TRIG_TX_BUF_TRIG_Pos    _UINT32_(0)                                          /* (QMSPI_BUF_CNT_TRIG) An interrupt is triggered if the TRANSMIT_BUFFER_COUNT field is less than or equal to this value. A value of 0 disables the interrupt. Position */
#define QMSPI_BUF_CNT_TRIG_TX_BUF_TRIG_Msk    (_UINT32_(0xFFFF) << QMSPI_BUF_CNT_TRIG_TX_BUF_TRIG_Pos) /* (QMSPI_BUF_CNT_TRIG) An interrupt is triggered if the TRANSMIT_BUFFER_COUNT field is less than or equal to this value. A value of 0 disables the interrupt. Mask */
#define QMSPI_BUF_CNT_TRIG_TX_BUF_TRIG(value) (QMSPI_BUF_CNT_TRIG_TX_BUF_TRIG_Msk & (_UINT32_(value) << QMSPI_BUF_CNT_TRIG_TX_BUF_TRIG_Pos)) /* Assigment of value for TX_BUF_TRIG in the QMSPI_BUF_CNT_TRIG register */
#define QMSPI_BUF_CNT_TRIG_RX_BUF_TRIG_Pos    _UINT32_(16)                                         /* (QMSPI_BUF_CNT_TRIG) An interrupt is triggered if the RECEIVE_BUFFER_COUNT field is greater than or equal to this value. A value of 0 disables the interrupt. Position */
#define QMSPI_BUF_CNT_TRIG_RX_BUF_TRIG_Msk    (_UINT32_(0xFFFF) << QMSPI_BUF_CNT_TRIG_RX_BUF_TRIG_Pos) /* (QMSPI_BUF_CNT_TRIG) An interrupt is triggered if the RECEIVE_BUFFER_COUNT field is greater than or equal to this value. A value of 0 disables the interrupt. Mask */
#define QMSPI_BUF_CNT_TRIG_RX_BUF_TRIG(value) (QMSPI_BUF_CNT_TRIG_RX_BUF_TRIG_Msk & (_UINT32_(value) << QMSPI_BUF_CNT_TRIG_RX_BUF_TRIG_Pos)) /* Assigment of value for RX_BUF_TRIG in the QMSPI_BUF_CNT_TRIG register */
#define QMSPI_BUF_CNT_TRIG_Msk                _UINT32_(0xFFFFFFFF)                                 /* (QMSPI_BUF_CNT_TRIG) Register Mask  */


/* -------- QMSPI_TX_FIFO : (QMSPI Offset: 0x20) (R/W 32) QMSPI Transmit Buffer Register -------- */
#define QMSPI_TX_FIFO_RESETVALUE              _UINT32_(0x00)                                       /*  (QMSPI_TX_FIFO) QMSPI Transmit Buffer Register  Reset Value */

#define QMSPI_TX_FIFO_TX_BUF_Pos              _UINT32_(0)                                          /* (QMSPI_TX_FIFO) Writes to this register store data to be transmitted from the SPI Master to the external SPI Slave.\n     Writes to this block will be written to the Transmit FIFO. A 1 Byte write fills 1 byte of the FIFO. A Word write fills 2 Bytes and a Doubleword write fills 4 bytes.\n     The data must always be aligned to the bottom most byte (so 1 byte write is on bits [7:0] and Word write is on [15:0]).\n     An overflow condition, TRANSMIT_BUFFER_ERROR, if a write to a full FIFO occurs. Write accesses to this register increment the TRANSMIT_BUFFER_COUNT field. Position */
#define QMSPI_TX_FIFO_TX_BUF_Msk              (_UINT32_(0xFFFFFFFF) << QMSPI_TX_FIFO_TX_BUF_Pos)   /* (QMSPI_TX_FIFO) Writes to this register store data to be transmitted from the SPI Master to the external SPI Slave.\n     Writes to this block will be written to the Transmit FIFO. A 1 Byte write fills 1 byte of the FIFO. A Word write fills 2 Bytes and a Doubleword write fills 4 bytes.\n     The data must always be aligned to the bottom most byte (so 1 byte write is on bits [7:0] and Word write is on [15:0]).\n     An overflow condition, TRANSMIT_BUFFER_ERROR, if a write to a full FIFO occurs. Write accesses to this register increment the TRANSMIT_BUFFER_COUNT field. Mask */
#define QMSPI_TX_FIFO_TX_BUF(value)           (QMSPI_TX_FIFO_TX_BUF_Msk & (_UINT32_(value) << QMSPI_TX_FIFO_TX_BUF_Pos)) /* Assigment of value for TX_BUF in the QMSPI_TX_FIFO register */
#define QMSPI_TX_FIFO_Msk                     _UINT32_(0xFFFFFFFF)                                 /* (QMSPI_TX_FIFO) Register Mask  */


/* -------- QMSPI_RX_FIFO : (QMSPI Offset: 0x24) (R/W 32) QMSPI Receive Buffer Register -------- */
#define QMSPI_RX_FIFO_RESETVALUE              _UINT32_(0x00)                                       /*  (QMSPI_RX_FIFO) QMSPI Receive Buffer Register  Reset Value */

#define QMSPI_RX_FIFO_RX_BUF_Pos              _UINT32_(0)                                          /* (QMSPI_RX_FIFO) Buffer that stores data from the external SPI Slave device to the SPI Master (this block), which is received over MISO or IO.\n     Reads from this register will empty the Rx FIFO. A 1 Byte read will have valid data on bits [7:0] and a Word read will have data on bits [15:0].\n     It is possible to request more data than the FIFO has (underflow condition), but this will cause an error (Rx Buffer Error).\n     Read accesses to this register decrement the RECEIVE_BUFFER_COUNT field. Position */
#define QMSPI_RX_FIFO_RX_BUF_Msk              (_UINT32_(0xFFFFFFFF) << QMSPI_RX_FIFO_RX_BUF_Pos)   /* (QMSPI_RX_FIFO) Buffer that stores data from the external SPI Slave device to the SPI Master (this block), which is received over MISO or IO.\n     Reads from this register will empty the Rx FIFO. A 1 Byte read will have valid data on bits [7:0] and a Word read will have data on bits [15:0].\n     It is possible to request more data than the FIFO has (underflow condition), but this will cause an error (Rx Buffer Error).\n     Read accesses to this register decrement the RECEIVE_BUFFER_COUNT field. Mask */
#define QMSPI_RX_FIFO_RX_BUF(value)           (QMSPI_RX_FIFO_RX_BUF_Msk & (_UINT32_(value) << QMSPI_RX_FIFO_RX_BUF_Pos)) /* Assigment of value for RX_BUF in the QMSPI_RX_FIFO register */
#define QMSPI_RX_FIFO_Msk                     _UINT32_(0xFFFFFFFF)                                 /* (QMSPI_RX_FIFO) Register Mask  */


/* -------- QMSPI_CSTM : (QMSPI Offset: 0x28) (R/W 32) QMSPI Chip Select Timing Register -------- */
#define QMSPI_CSTM_RESETVALUE                 _UINT32_(0x6060406)                                  /*  (QMSPI_CSTM) QMSPI Chip Select Timing Register  Reset Value */

#define QMSPI_CSTM_DLY_CS_ON_CLK_STRT_Pos     _UINT32_(0)                                          /* (QMSPI_CSTM)  Position */
#define QMSPI_CSTM_DLY_CS_ON_CLK_STRT_Msk     (_UINT32_(0xF) << QMSPI_CSTM_DLY_CS_ON_CLK_STRT_Pos) /* (QMSPI_CSTM)  Mask */
#define QMSPI_CSTM_DLY_CS_ON_CLK_STRT(value)  (QMSPI_CSTM_DLY_CS_ON_CLK_STRT_Msk & (_UINT32_(value) << QMSPI_CSTM_DLY_CS_ON_CLK_STRT_Pos)) /* Assigment of value for DLY_CS_ON_CLK_STRT in the QMSPI_CSTM register */
#define QMSPI_CSTM_DLY_CLK_STOP_CS_OFF_Pos    _UINT32_(8)                                          /* (QMSPI_CSTM) This selects the number of system clock cycles between the last clock edge and the deassertion of CS.\n Position */
#define QMSPI_CSTM_DLY_CLK_STOP_CS_OFF_Msk    (_UINT32_(0xF) << QMSPI_CSTM_DLY_CLK_STOP_CS_OFF_Pos) /* (QMSPI_CSTM) This selects the number of system clock cycles between the last clock edge and the deassertion of CS.\n Mask */
#define QMSPI_CSTM_DLY_CLK_STOP_CS_OFF(value) (QMSPI_CSTM_DLY_CLK_STOP_CS_OFF_Msk & (_UINT32_(value) << QMSPI_CSTM_DLY_CLK_STOP_CS_OFF_Pos)) /* Assigment of value for DLY_CLK_STOP_CS_OFF in the QMSPI_CSTM register */
#define QMSPI_CSTM_DLY_LAST_DAT_HLD_Pos       _UINT32_(16)                                         /* (QMSPI_CSTM) This selects the number of system clock cycles between CS deassertion to the data ports for WP and HOLD \n    switching from input to output. This is only used if the WP/HOLD functions are in use and only on IO2/WP \n           and IO3/HOLD pins. Position */
#define QMSPI_CSTM_DLY_LAST_DAT_HLD_Msk       (_UINT32_(0xF) << QMSPI_CSTM_DLY_LAST_DAT_HLD_Pos)   /* (QMSPI_CSTM) This selects the number of system clock cycles between CS deassertion to the data ports for WP and HOLD \n    switching from input to output. This is only used if the WP/HOLD functions are in use and only on IO2/WP \n           and IO3/HOLD pins. Mask */
#define QMSPI_CSTM_DLY_LAST_DAT_HLD(value)    (QMSPI_CSTM_DLY_LAST_DAT_HLD_Msk & (_UINT32_(value) << QMSPI_CSTM_DLY_LAST_DAT_HLD_Pos)) /* Assigment of value for DLY_LAST_DAT_HLD in the QMSPI_CSTM register */
#define QMSPI_CSTM_DLY_OFF_TO_ON_Pos          _UINT32_(23)                                         /* (QMSPI_CSTM) This selects the number of system clock cycles between CS deassertion to CS assertion. This is the minimum \n           pulse width of CS deassertion. Position */
#define QMSPI_CSTM_DLY_OFF_TO_ON_Msk          (_UINT32_(0x1FF) << QMSPI_CSTM_DLY_OFF_TO_ON_Pos)    /* (QMSPI_CSTM) This selects the number of system clock cycles between CS deassertion to CS assertion. This is the minimum \n           pulse width of CS deassertion. Mask */
#define QMSPI_CSTM_DLY_OFF_TO_ON(value)       (QMSPI_CSTM_DLY_OFF_TO_ON_Msk & (_UINT32_(value) << QMSPI_CSTM_DLY_OFF_TO_ON_Pos)) /* Assigment of value for DLY_OFF_TO_ON in the QMSPI_CSTM register */
#define QMSPI_CSTM_Msk                        _UINT32_(0xFF8F0F0F)                                 /* (QMSPI_CSTM) Register Mask  */


/* -------- QMSPI_DESCR : (QMSPI Offset: 0x30) (R/W 32) QMSPI Description Buffer 0 Register -------- */
#define QMSPI_DESCR_RESETVALUE                _UINT32_(0x00)                                       /*  (QMSPI_DESCR) QMSPI Description Buffer 0 Register  Reset Value */

#define QMSPI_DESCR_INFACE_MOD_Pos            _UINT32_(0)                                          /* (QMSPI_DESCR) This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. Position */
#define QMSPI_DESCR_INFACE_MOD_Msk            (_UINT32_(0x3) << QMSPI_DESCR_INFACE_MOD_Pos)        /* (QMSPI_DESCR) This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode. Mask */
#define QMSPI_DESCR_INFACE_MOD(value)         (QMSPI_DESCR_INFACE_MOD_Msk & (_UINT32_(value) << QMSPI_DESCR_INFACE_MOD_Pos)) /* Assigment of value for INFACE_MOD in the QMSPI_DESCR register */
#define QMSPI_DESCR_TX_TRANS_EN_Pos           _UINT32_(2)                                          /* (QMSPI_DESCR) This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. Position */
#define QMSPI_DESCR_TX_TRANS_EN_Msk           (_UINT32_(0x3) << QMSPI_DESCR_TX_TRANS_EN_Pos)       /* (QMSPI_DESCR) This field bit selects the transmit function of the SPI interface.\n     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled. Mask */
#define QMSPI_DESCR_TX_TRANS_EN(value)        (QMSPI_DESCR_TX_TRANS_EN_Msk & (_UINT32_(value) << QMSPI_DESCR_TX_TRANS_EN_Pos)) /* Assigment of value for TX_TRANS_EN in the QMSPI_DESCR register */
#define QMSPI_DESCR_TX_DMA_EN_Pos             _UINT32_(4)                                          /* (QMSPI_DESCR) This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. Position */
#define QMSPI_DESCR_TX_DMA_EN_Msk             (_UINT32_(0x3) << QMSPI_DESCR_TX_DMA_EN_Pos)         /* (QMSPI_DESCR) This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n      2=DMA is enabled and set to 2 Bytes\n      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware. Mask */
#define QMSPI_DESCR_TX_DMA_EN(value)          (QMSPI_DESCR_TX_DMA_EN_Msk & (_UINT32_(value) << QMSPI_DESCR_TX_DMA_EN_Pos)) /* Assigment of value for TX_DMA_EN in the QMSPI_DESCR register */
#define QMSPI_DESCR_RX_TRANS_EN_Pos           _UINT32_(6)                                          /* (QMSPI_DESCR) This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. Position */
#define QMSPI_DESCR_RX_TRANS_EN_Msk           (_UINT32_(0x1) << QMSPI_DESCR_RX_TRANS_EN_Pos)       /* (QMSPI_DESCR) This bit enables the receive function of the SPI interface.\n     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled. Mask */
#define QMSPI_DESCR_RX_TRANS_EN(value)        (QMSPI_DESCR_RX_TRANS_EN_Msk & (_UINT32_(value) << QMSPI_DESCR_RX_TRANS_EN_Pos)) /* Assigment of value for RX_TRANS_EN in the QMSPI_DESCR register */
#define QMSPI_DESCR_RX_DMA_EN_Pos             _UINT32_(7)                                          /* (QMSPI_DESCR) This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. Position */
#define QMSPI_DESCR_RX_DMA_EN_Msk             (_UINT32_(0x3) << QMSPI_DESCR_RX_DMA_EN_Pos)         /* (QMSPI_DESCR) This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n     1=DMA is enabled.and set to 1 Byte\n     2=DMA is enabled and set to 2 Bytes\n     3=DMA is enabled and set to 4 Bytes\n     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware. Mask */
#define QMSPI_DESCR_RX_DMA_EN(value)          (QMSPI_DESCR_RX_DMA_EN_Msk & (_UINT32_(value) << QMSPI_DESCR_RX_DMA_EN_Pos)) /* Assigment of value for RX_DMA_EN in the QMSPI_DESCR register */
#define QMSPI_DESCR_CLOSE_TRANS_EN_Pos        _UINT32_(9)                                          /* (QMSPI_DESCR) This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active Position */
#define QMSPI_DESCR_CLOSE_TRANS_EN_Msk        (_UINT32_(0x1) << QMSPI_DESCR_CLOSE_TRANS_EN_Pos)    /* (QMSPI_DESCR) This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active Mask */
#define QMSPI_DESCR_CLOSE_TRANS_EN(value)     (QMSPI_DESCR_CLOSE_TRANS_EN_Msk & (_UINT32_(value) << QMSPI_DESCR_CLOSE_TRANS_EN_Pos)) /* Assigment of value for CLOSE_TRANS_EN in the QMSPI_DESCR register */
#define QMSPI_DESCR_TRANS_LEN_BITS_Pos        _UINT32_(10)                                         /* (QMSPI_DESCR) 1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes Position */
#define QMSPI_DESCR_TRANS_LEN_BITS_Msk        (_UINT32_(0x1) << QMSPI_DESCR_TRANS_LEN_BITS_Pos)    /* (QMSPI_DESCR) 1=TRANSFER_LENGTH defined in bits\n      0=TRANSFER_LENGTH defined in bytes Mask */
#define QMSPI_DESCR_TRANS_LEN_BITS(value)     (QMSPI_DESCR_TRANS_LEN_BITS_Msk & (_UINT32_(value) << QMSPI_DESCR_TRANS_LEN_BITS_Pos)) /* Assigment of value for TRANS_LEN_BITS in the QMSPI_DESCR register */
#define QMSPI_DESCR_DESCR_BUF_LAST_Pos        _UINT32_(11)                                         /* (QMSPI_DESCR) If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. Position */
#define QMSPI_DESCR_DESCR_BUF_LAST_Msk        (_UINT32_(0x1) << QMSPI_DESCR_DESCR_BUF_LAST_Pos)    /* (QMSPI_DESCR) If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_COMPLETE status will be set to 1.\n     If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted. Mask */
#define QMSPI_DESCR_DESCR_BUF_LAST(value)     (QMSPI_DESCR_DESCR_BUF_LAST_Msk & (_UINT32_(value) << QMSPI_DESCR_DESCR_BUF_LAST_Pos)) /* Assigment of value for DESCR_BUF_LAST in the QMSPI_DESCR register */
#define QMSPI_DESCR_DESCR_BUF_NXT_PTR_Pos     _UINT32_(12)                                         /* (QMSPI_DESCR) This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. Position */
#define QMSPI_DESCR_DESCR_BUF_NXT_PTR_Msk     (_UINT32_(0xF) << QMSPI_DESCR_DESCR_BUF_NXT_PTR_Pos) /* (QMSPI_DESCR) This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop. Mask */
#define QMSPI_DESCR_DESCR_BUF_NXT_PTR(value)  (QMSPI_DESCR_DESCR_BUF_NXT_PTR_Msk & (_UINT32_(value) << QMSPI_DESCR_DESCR_BUF_NXT_PTR_Pos)) /* Assigment of value for DESCR_BUF_NXT_PTR in the QMSPI_DESCR register */
#define QMSPI_DESCR_TX_LEN_Pos                _UINT32_(16)                                         /* (QMSPI_DESCR) The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. Position */
#define QMSPI_DESCR_TX_LEN_Msk                (_UINT32_(0xFFFF) << QMSPI_DESCR_TX_LEN_Pos)         /* (QMSPI_DESCR) The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer. Mask */
#define QMSPI_DESCR_TX_LEN(value)             (QMSPI_DESCR_TX_LEN_Msk & (_UINT32_(value) << QMSPI_DESCR_TX_LEN_Pos)) /* Assigment of value for TX_LEN in the QMSPI_DESCR register */
#define QMSPI_DESCR_Msk                       _UINT32_(0xFFFFFFFF)                                 /* (QMSPI_DESCR) Register Mask  */


/** \brief QMSPI register offsets definitions */
#define QMSPI_MODE_REG_OFST            _UINT32_(0x00)      /* (QMSPI_MODE) QMSPI Mode Register Offset */
#define QMSPI_CTRL_REG_OFST            _UINT32_(0x04)      /* (QMSPI_CTRL) QMSPI SPI Control Offset */
#define QMSPI_EXE_REG_OFST             _UINT32_(0x08)      /* (QMSPI_EXE) QMSPI Execute Register Offset */
#define QMSPI_IFCTRL_REG_OFST          _UINT32_(0x0C)      /* (QMSPI_IFCTRL) QMSPI Interface Control Register Offset */
#define QMSPI_STS_REG_OFST             _UINT32_(0x10)      /* (QMSPI_STS) QMSPI Status Register Offset */
#define QMSPI_BUF_CNT_STS_REG_OFST     _UINT32_(0x14)      /* (QMSPI_BUF_CNT_STS) QMSPI Buffer Count Status Register Offset */
#define QMSPI_IEN_REG_OFST             _UINT32_(0x18)      /* (QMSPI_IEN) QMSPI Interrupt Enable Register Offset */
#define QMSPI_BUF_CNT_TRIG_REG_OFST    _UINT32_(0x1C)      /* (QMSPI_BUF_CNT_TRIG) QMSPI Buffer Count Trigger Register Offset */
#define QMSPI_TX_FIFO_REG_OFST         _UINT32_(0x20)      /* (QMSPI_TX_FIFO) QMSPI Transmit Buffer Register Offset */
#define QMSPI_RX_FIFO_REG_OFST         _UINT32_(0x24)      /* (QMSPI_RX_FIFO) QMSPI Receive Buffer Register Offset */
#define QMSPI_CSTM_REG_OFST            _UINT32_(0x28)      /* (QMSPI_CSTM) QMSPI Chip Select Timing Register Offset */
#define QMSPI_DESCR_REG_OFST           _UINT32_(0x30)      /* (QMSPI_DESCR) QMSPI Description Buffer 0 Register Offset */
#define QMSPI_DESCR0_REG_OFST          _UINT32_(0x30)      /* (QMSPI_DESCR0) QMSPI Description Buffer 0 Register Offset */
#define QMSPI_DESCR1_REG_OFST          _UINT32_(0x34)      /* (QMSPI_DESCR1) QMSPI Description Buffer 0 Register Offset */
#define QMSPI_DESCR2_REG_OFST          _UINT32_(0x38)      /* (QMSPI_DESCR2) QMSPI Description Buffer 0 Register Offset */
#define QMSPI_DESCR3_REG_OFST          _UINT32_(0x3C)      /* (QMSPI_DESCR3) QMSPI Description Buffer 0 Register Offset */
#define QMSPI_DESCR4_REG_OFST          _UINT32_(0x40)      /* (QMSPI_DESCR4) QMSPI Description Buffer 0 Register Offset */
#define QMSPI_DESCR5_REG_OFST          _UINT32_(0x44)      /* (QMSPI_DESCR5) QMSPI Description Buffer 0 Register Offset */
#define QMSPI_DESCR6_REG_OFST          _UINT32_(0x48)      /* (QMSPI_DESCR6) QMSPI Description Buffer 0 Register Offset */
#define QMSPI_DESCR7_REG_OFST          _UINT32_(0x4C)      /* (QMSPI_DESCR7) QMSPI Description Buffer 0 Register Offset */
#define QMSPI_DESCR8_REG_OFST          _UINT32_(0x50)      /* (QMSPI_DESCR8) QMSPI Description Buffer 0 Register Offset */
#define QMSPI_DESCR9_REG_OFST          _UINT32_(0x54)      /* (QMSPI_DESCR9) QMSPI Description Buffer 0 Register Offset */
#define QMSPI_DESCR10_REG_OFST         _UINT32_(0x58)      /* (QMSPI_DESCR10) QMSPI Description Buffer 0 Register Offset */
#define QMSPI_DESCR11_REG_OFST         _UINT32_(0x5C)      /* (QMSPI_DESCR11) QMSPI Description Buffer 0 Register Offset */
#define QMSPI_DESCR12_REG_OFST         _UINT32_(0x60)      /* (QMSPI_DESCR12) QMSPI Description Buffer 0 Register Offset */
#define QMSPI_DESCR13_REG_OFST         _UINT32_(0x64)      /* (QMSPI_DESCR13) QMSPI Description Buffer 0 Register Offset */
#define QMSPI_DESCR14_REG_OFST         _UINT32_(0x68)      /* (QMSPI_DESCR14) QMSPI Description Buffer 0 Register Offset */
#define QMSPI_DESCR15_REG_OFST         _UINT32_(0x6C)      /* (QMSPI_DESCR15) QMSPI Description Buffer 0 Register Offset */

#if !(defined(__ASSEMBLER__) || defined(__IAR_SYSTEMS_ASM__))
/** \brief QMSPI register API structure */
typedef struct
{  /* The QMSPI may be used to communicate with various peripheral devices that use a Serial Peripheral Interface */
  __IO  uint32_t                       QMSPI_MODE;         /**< Offset: 0x00 (R/W  32) QMSPI Mode Register */
  __IO  uint32_t                       QMSPI_CTRL;         /**< Offset: 0x04 (R/W  32) QMSPI SPI Control */
  __IO  uint32_t                       QMSPI_EXE;          /**< Offset: 0x08 (R/W  32) QMSPI Execute Register */
  __IO  uint32_t                       QMSPI_IFCTRL;       /**< Offset: 0x0C (R/W  32) QMSPI Interface Control Register */
  __IO  uint32_t                       QMSPI_STS;          /**< Offset: 0x10 (R/W  32) QMSPI Status Register */
  __IO  uint32_t                       QMSPI_BUF_CNT_STS;  /**< Offset: 0x14 (R/W  32) QMSPI Buffer Count Status Register */
  __IO  uint32_t                       QMSPI_IEN;          /**< Offset: 0x18 (R/W  32) QMSPI Interrupt Enable Register */
  __IO  uint32_t                       QMSPI_BUF_CNT_TRIG; /**< Offset: 0x1C (R/W  32) QMSPI Buffer Count Trigger Register */
  __IO  uint32_t                       QMSPI_TX_FIFO;      /**< Offset: 0x20 (R/W  32) QMSPI Transmit Buffer Register */
  __IO  uint32_t                       QMSPI_RX_FIFO;      /**< Offset: 0x24 (R/W  32) QMSPI Receive Buffer Register */
  __IO  uint32_t                       QMSPI_CSTM;         /**< Offset: 0x28 (R/W  32) QMSPI Chip Select Timing Register */
  __I   uint8_t                        Reserved1[0x04];
  __IO  uint32_t                       QMSPI_DESCR[16];    /**< Offset: 0x30 (R/W  32) QMSPI Description Buffer 0 Register */
} qmspi_registers_t;


#endif /* !(defined(__ASSEMBLER__) || defined(__IAR_SYSTEMS_ASM__)) */
#endif /* _0525SG12_QMSPI_COMPONENT_H_ */
