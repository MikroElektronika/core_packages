# This is a basic workflow that is manually triggered

name: CORE generation no build

# Controls when the action will run. Workflow runs when manually triggered using the UI
# or API.
on:
  workflow_dispatch:
    # Inputs the workflow accepts.
    inputs:
      mcu_name:
        # Name of the MCU for which generation is running
        description: 'MCU name'
        # Default value if no value is explicitly provided
        default: 'mk10dn32vfm5'
        # Input has to be provided for the workflow to run
        required: true
        # The data type of the input
        type: string
      vendor:
        # Vendor of the MCU
        description: 'Vendor'
        # Default value if no value is explicitly provided
        default: 'nxp'
        # Input has to be provided for the workflow to run
        required: true
        # The data type of the input
        type: string
      architecture:
        # Architecture of the MCU
        description: 'Architecture'
        # Default value if no value is explicitly provided
        default: 'ARM'
        # Input has to be provided for the workflow to run
        required: true
        # The data type of the input
        type: string
      pdfFile:
        # Path to the reference manual PDF file
        description: 'Reference manual PDF file path'
        # Default value if no value is explicitly provided
        default: '/tmp/documentation/mk10dn32vfm5_rm.pdf'
        # Input has to be provided for the workflow to run
        required: true
        # The data type of the input
        type: string
      release_date:
        # Release date from the release calendar
        description: 'Release date from the release calendar. Takes current date if not changed.'
        # Default value if no value is explicitly provided
        default: '2000-01-01'
        # Input has to be provided for the workflow to run
        required: true
        # The data type of the input
        type: string
      new_branch:
        type: bool
        description: 'To create a new branch for this run or use the last one'
        default: true
      build_version:
        type: string
        description: 'Tag to use for script run (i.e. v1.0.7)'
        default: "latest"
      file_list:
        # List of files to be generated
        description: 'List of selected files to be generated. If set to "all", all files are generated.'
        # Default value
        default: 'all'
        # Input is optional
        required: false
        # The data type of the input
        type: string


env:
  NVIDIA_API_KEY: ${{ secrets.NVIDIA_API_KEY }}

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "Generate CORE"
  Generate_Core:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:

    # Runs a single command using the runners shell
    - name: Send greeting
      run: echo "Starting CORE generation workflow..."
    # Checkout branch
    - uses: actions/checkout@v4

    - name: Authorize Mikroe Actions App
      uses: actions/create-github-app-token@v1
      id: app-token
      with:
        app-id: ${{ vars.MIKROE_ACTIONS }}
        private-key: ${{ secrets.MIKROE_ACTIONS_KEY_AUTHORIZE }}

    - name: Add GitHub Actions credentials
      run: |
        git config user.name github-actions
        git config user.email github-actions@github.com

    # Create a new branch
    - name: Create branch
      id: branch-creation
      env:
        RELEASES_SPREADSHEET: ${{ secrets.RELEASES_SPREADSHEET }}
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        branchInfo=$(python -u scripts/release_calendar.py --title "NECTO DAILY UPDATE" --doc_link $RELEASES_SPREADSHEET --chose_data "branches" --release_date "${{ github.event.inputs.release_date }}")
        mcuInfo=$(python -u scripts/release_calendar.py --title "NECTO DAILY UPDATE" --doc_link $RELEASES_SPREADSHEET --chose_data "mcus" --release_date "${{ github.event.inputs.release_date }}")
        cmakeInfo=$(python -u scripts/release_calendar.py --title "NECTO DAILY UPDATE" --doc_link $RELEASES_SPREADSHEET --chose_data "cmakes" --release_date "${{ github.event.inputs.release_date }}")

        branchInfoArray=($(echo "$branchInfo" | tr -d "[]'," | tr -s ' ' '\n'))
        if [ "${branchInfoArray[0]}" == "NO_BRANCH_IN_SPREADSHEET" ]; then
          echo "Check the Google spreadsheet, $branchName!"
          exit 1
        fi
        echo "Found branch: ${branchInfoArray[0]}!"

        echo "branch_info=${branchInfo}" >> $GITHUB_OUTPUT
        echo "mcu_info=${mcuInfo}" >> $GITHUB_OUTPUT
        echo "cmake_info=${cmakeInfo}" >> $GITHUB_OUTPUT

    # Create a new directory at the root of your repository
    - name: Create automatization directory
      run: mkdir -p automatization

    # MCU name to uppercase
    - id: upper-mcu-name
      name: MCU name uppercase
      run: |
        mcu_name=${{ github.event.inputs.mcu_name }}
        echo "mcu_name=${mcu_name^^}" >> $GITHUB_OUTPUT

    # Check if release asset exists - if CORE files are already generated for this MCU
    - id: check-asset-existence
      name: Fetch CORE files if already generated
      continue-on-error: true
      env:
        GH_TOKEN: ${{ secrets.MIKROE_ACTIONS_KEY }}
        RELEASES_SPREADSHEET: ${{ secrets.RELEASES_SPREADSHEET }}
      run: |
        refManNumber=$(python -u scripts/release_calendar.py --title "NECTO DAILY UPDATE" --doc_link $RELEASES_SPREADSHEET --chose_data "ref_manual" --release_date "${{ github.event.inputs.release_date }}")
        refManNumber="${refManNumber//\//_}"
        gh release download --repo MikroElektronika/sdk_automation latest --pattern "extracted_${refManNumber}.zip"
        echo "exit_code=$?" >> $GITHUB_OUTPUT

    - name: Verify if assets were found
      if: steps.check-asset-existence.outcome != 'success'
      run: |
        echo "Generated files not found. Exiting."
        exit 1

    # Move the asset we just downloaded to automatization, extract it and for each MCU create branch and copy files to where they should be
    - name: Move to the created directory unzip and distribute files
      if: steps.check-asset-existence.outcome == 'success'
      id: move_files
      env:
        GH_TOKEN: ${{ secrets.MIKROE_ACTIONS_KEY }}
        RELEASES_SPREADSHEET: ${{ secrets.RELEASES_SPREADSHEET }}
      run: |
        currentBranch=$(git rev-parse --abbrev-ref HEAD)
        echo "current branch is: $currentBranch"
        refManNumber=$(python -u scripts/release_calendar.py --title "NECTO DAILY UPDATE" --doc_link $RELEASES_SPREADSHEET --chose_data "ref_manual" --release_date "${{ github.event.inputs.release_date }}")
        systemPath=${refManNumber//rm/ds}
        refManNumber="${refManNumber//\//_}"
        sudo mv extracted_${refManNumber}.zip automatization/
        cd automatization
        unzip extracted_${refManNumber}.zip

        branchInfoArray=($(echo "${{steps.branch-creation.outputs.branch_info}}" | tr -d "[]'," | tr -s ' ' '\n'))
        mcuInfoArray=($(echo "${{steps.branch-creation.outputs.mcu_info}}" | tr -d "[]'," | tr -s ' ' '\n'))
        cmakeInfoArray=($(echo "${{steps.branch-creation.outputs.cmake_info}}" | tr -d "[]'," | tr -s ' ' '\n'))
        dirInfoArray=( */ )
        cd ..

        echo "MCU INFO ARRAY IS: ${mcuInfoArray}"

        # Check if the directory name matches any branch name in the array
        for i in "${!branchInfoArray[@]}"; do
          if ${{ github.event.inputs.new_branch }} == true; then
            git branch ${branchInfoArray[i]}
            git checkout ${branchInfoArray[i]}
            git push -u origin ${branchInfoArray[i]}
          else
            git checkout ${branchInfoArray[i]}
            git reset --hard $(git rev-list --max-parents=1 )
          fi

          cd automatization
          unzip -o extracted_${refManNumber}.zip
          echo "CMAKE NAME: $(find . -maxdepth 1 -name '*.cmake' | head -n 1)"
          echo "CMAKE REGEX: ${mcuInfoArray[i]}"

          for dir in ${dirInfoArray[@]}; do
            dirName="${dir%/}"
            if [ ${mcuInfoArray[i]} != ${mcuInfoArray[i]//${dirName/#extracted_}/} ]; then

              cd $dirName
              cd generatedFiles
              unzip generated_files.zip
              python -u ../../../scripts/edit_cmake.py --cmake_name "$(find . -maxdepth 1 -name '*.cmake' | head -n 1)" --cmake_regex "${mcuInfoArray[i]}" --cmake_new_name "${cmakeInfoArray[i]}"
              json_name=$(basename $(find . -maxdepth 1 -name '*.json' | head -n 1))
              echo "JSON_NAME: $json_name"

              mkdir -p ../../../${{ github.event.inputs.architecture }}/gcc_clang/def/${{ github.event.inputs.vendor }}/${dirName/#extracted_}
              mkdir -p ../../../${{ github.event.inputs.architecture }}/gcc_clang/interrupts/include/interrupts_mcu/$(echo ${dirName/#extracted_} | tr '[:upper:]' '[:lower:]')
              mkdir -p ../../../${{ github.event.inputs.architecture }}/gcc_clang/system/src/${systemPath}

              echo "moving ${dirName/#extracted_}"
              sudo mv "${dirName/#extracted_}" ../../../resources/queries/mcus/
              echo "moving mcu.h"
              sudo mv 'mcu.h' ../../../${{ github.event.inputs.architecture }}/gcc_clang/def/${{ github.event.inputs.vendor }}/${dirName/#extracted_}/
              echo "moving $(find . -maxdepth 1 -name '*.json' | head -n 1)"
              sudo mv "$(find . -maxdepth 1 -name '*.json' | head -n 1)" ../../../${{ github.event.inputs.architecture }}/gcc_clang/def/
              echo "moving interrupts_mcu.h"
              sudo mv 'interrupts_mcu.h' ../../../${{ github.event.inputs.architecture }}/gcc_clang/interrupts/include/interrupts_mcu/$(echo ${dirName/#extracted_} | tr '[:upper:]' '[:lower:]')/
              echo "moving init_clock.c"
              sudo mv 'init_clock.c' ../../../${{ github.event.inputs.architecture }}/gcc_clang/system/src/${systemPath}/
              echo "moving $(find . -maxdepth 1 -name '*.ld' | head -n 1)"
              sudo mv "$(find . -maxdepth 1 -name '*.ld' | head -n 1)" ../../../${{ github.event.inputs.architecture }}/gcc_clang/linker_scripts/${{ github.event.inputs.vendor }}/$(echo $(find . -maxdepth 1 -name '*.ld' | head -n 1) | tr '[:upper:]' '[:lower:]')
              echo "moving $(find . -maxdepth 1 -name '*.s' | head -n 1)"
              sudo mv "$(find . -maxdepth 1 -name '*.s' | head -n 1)" ../../../${{ github.event.inputs.architecture }}/gcc_clang/startup/${{ github.event.inputs.vendor }}/$(echo $(find . -maxdepth 1 -name '*.s' | head -n 1) | tr '[:upper:]' '[:lower:]')
              echo "moving $(find . -maxdepth 1 -name '*.cmake' | head -n 1)"
              sudo mv "$(find . -maxdepth 1 -name '*.cmake' | head -n 1)" ../../../${{ github.event.inputs.architecture }}/gcc_clang/cmake/${{ github.event.inputs.vendor }}/"${cmakeInfoArray[i]}.cmake"
              cd delays
              echo "moving $(find . -maxdepth 1 -name '*.cmake' | head -n 1)"
              sudo mv "$(find . -maxdepth 1 -name '*.cmake' | head -n 1)" ../../../../${{ github.event.inputs.architecture }}/gcc_clang/cmake/${{ github.event.inputs.vendor }}/delays/"${cmakeInfoArray[i]}.cmake"

              cd ..
              cd ..
              cd ..
            fi
          done
          cd ..

          core_name=${{ github.event.inputs.architecture }}/gcc_clang/def/$json_name
          echo "finding CORE: ${core_name}"
          echo "processing json to find CORE"
          CORE=$(jq -r '.core' ./${{ github.event.inputs.architecture }}/gcc_clang/def/$json_name | tr '[:upper:]' '[:lower:]')
          echo "found CORE: ${CORE}"
          echo "entering IF:"
          if [ -d "./${{ github.event.inputs.architecture }}/gcc_clang/delays/$CORE" ]; then
            echo "Core already exists: $CORE"
          else
            mkdir "./${{ github.event.inputs.architecture }}/gcc_clang/delays/$CORE"
            sudo mv './${{ github.event.inputs.architecture }}/gcc_clang/delays/m4/delays.c' ./${{ github.event.inputs.architecture }}/gcc_clang/delays/$CORE/
            echo "Found new core: $CORE"
          fi

          rm -rf automatization
          # Commit changes
          git add .
          git commit -m "Pulled files from sdk_automation into core_packages"
          # Push changes back to your repository
          git push -u origin ${{ github.event.inputs.build_branch }}
          git checkout ${currentBranch}

          mkdir -p automatization
          gh release download --repo MikroElektronika/sdk_automation latest --pattern "extracted_${refManNumber}.zip"
          sudo mv extracted_${refManNumber}.zip automatization/
        done
