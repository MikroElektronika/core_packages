# This is a basic workflow that is manually triggered

name: CORE generation

# Controls when the action will run. Workflow runs when manually triggered using the UI
# or API.
on:
  workflow_dispatch:
    # Inputs the workflow accepts.
    inputs:
      mcu_name:
        # Name of the MCU for which generation is running
        description: 'MCU name'
        # Default value if no value is explicitly provided
        default: 'mk20dn32vlh5'
        # Input has to be provided for the workflow to run
        required: true
        # The data type of the input
        type: string
      vendor:
        # Vendor of the MCU
        description: 'Vendor'
        # Default value if no value is explicitly provided
        default: 'nxp'
        # Input has to be provided for the workflow to run
        required: true
        # The data type of the input
        type: string
      architecture:
        # Architecture of the MCU
        description: 'Architecture'
        # Default value if no value is explicitly provided
        default: 'ARM'
        # Input has to be provided for the workflow to run
        required: true
        # The data type of the input
        type: string
      pdfFile:
        # Path to the reference manual PDF file
        description: 'Reference manual PDF file path'
        # Default value if no value is explicitly provided
        default: '/tmp/documentation/mk20dn32vlh5_rm.pdf'
        # Input has to be provided for the workflow to run
        required: true
        # The data type of the input
        type: string
      new_branch:
        type: bool
        description: 'To create a new branch for this run or use the last one'
        default: true
      build_version:
        type: string
        description: 'Tag to use for script run (i.e. v1.0.7)'
        default: "latest"
      file_list:
        # List of files to be generated
        description: 'List of selected files to be generated. If set to "all", all files are generated.'
        # Default value
        default: 'all'
        # Input is optional
        required: false
        # The data type of the input
        type: string
      

env:
  NVIDIA_API_KEY: ${{ secrets.NVIDIA_API_KEY }}

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "Generate CORE"
  Generate_Core:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:

    # Runs a single command using the runners shell
    - name: Send greeting
      run: echo "Starting CORE generation workflow..."
    # Checkout branch
    - uses: actions/checkout@v2

    - name: Authorize Mikroe Actions App
      uses: actions/create-github-app-token@v1
      id: app-token
      with:
        app-id: ${{ vars.MIKROE_ACTIONS }}
        private-key: ${{ secrets.MIKROE_ACTIONS_KEY_AUTHORIZE }}

    - name: Add GitHub Actions credentials
      run: |
        git config user.name github-actions
        git config user.email github-actions@github.com

    # Create a new branch
    - name: Create branch
      env:
        RELEASES_SPREADSHEET: ${{ secrets.RELEASES_SPREADSHEET }}
      run: |
        # branchName=$(python -u scripts/release_calendar.py --title "NECTO DAILY UPDATE" --doc_link $RELEASES_SPREADSHEET)
        # if [ "$branchName" == "NO_BRANCH_IN_SPREADSHEET" ]; then
        #   echo "Check the Google spreadsheet, $branchName!"
        #   exit 1
        # fi
        # echo "Found branch: $branchName"

        branchName="workflow_test_branch_sz"

        if ${{ github.event.inputs.new_branch }} == true; then
          git branch $branchName
          git checkout $branchName
          git push -u origin $branchName
        else
          git checkout $branchName
          git reset --hard $(git rev-list --max-parents=1 )
        fi

    # Create a new directory at the root of your repository
    - name: Create automatization directory
      run: mkdir -p automatization

    # MCU name to uppercase
    - id: upper-mcu-name
      name: MCU name uppercase
      run: |
        mcu_name=${{ github.event.inputs.mcu_name }}
        echo "mcu_name=${mcu_name^^}" >> $GITHUB_OUTPUT

    # # Get a list of release assets (generated CORE files)
    # - id: get-asset-list
    #   name: Fetch a list of release assets
    #   env:
    #     GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    #   run: |
    #     gh api repos/MikroElektronika/sdk_automation/releases/latest | jq -r ".assets[].name"
    #     # release=$(curl -s -H "Authorization: token ${{ env.GH_TOKEN }}" \
    #     #   "https://api.github.com/repos/MikroElektronika/sdk_automation/releases/tags/latest")
        
    #     # assets=$(echo "$release" | jq -r '.assets[] | {name: .name, download_url: .browser_download_url}')
        
    #     # echo "Assets: $assets"
    #     # echo "::set-output name=assets::$assets"

    #     # echo "Assets: ${{ steps.get-assets.outputs.assets }}"

    
    # Check if release asset exists - if CORE files are already generated for this MCU
    - id: check-asset-existence
      name: Fetch CORE files if already generated
      continue-on-error: true
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        gh release download --repo MikroElektronika/sdk_automation latest --pattern 'extracted_${{ steps.upper-mcu-name.outputs.mcu_name }}.zip'
        echo "exit_code=$?" >> $GITHUB_OUTPUT

    - name: Verify if assets were found
      if: steps.check-asset-existence.outcome != 'success'
      run: |
        echo "Generated files not found. Starting generation workflow."

    
    # Trigger the workflow on the private repository (Assuming the private repository has a workflow that runs on repository_dispatch event)
    - name: Trigger Workflow on Private Repository
      if: steps.check-asset-existence.outcome != 'success'
      env:
        REPO: "MikroElektronika/sdk_automation"
      run: |
        curl -s \
          -X POST \
          -H "Accept: application/vnd.github+json" \
          -H "Authorization: Bearer ${{ secrets.MIKROE_ACTIONS_KEY }}" \
          -H "X-GitHub-Api-Version: 2022-11-28" \
          https://api.github.com/repos/$REPO/actions/workflows/generate_core.yml/dispatches \
          -d '{
                "ref": "main",
                "inputs": {
                  "mcu_name": "${{ github.event.inputs.mcu_name }}",
                  "vendor": "${{ github.event.inputs.vendor }}",
                  "pdfFile": "${{ github.event.inputs.pdfFile }}",
                  "file_list": "${{ github.event.inputs.file_list }}"
                }
              }'

    # Wait for workflow start
    - name: Wait for start
      if: steps.check-asset-existence.outcome != 'success'
      run: sleep 5

    # Get the ID of the run that we just triggered
    - name: Get run ID
      if: steps.check-asset-existence.outcome != 'success'
      id: get_id
      env:
        REPO: "MikroElektronika/sdk_automation"
        GH_TOKEN: ${{ secrets.MIKROE_ACTIONS_KEY }}
      run: |
        while : ; do
          runID=$(gh api \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              repos/$REPO/actions/workflows/generate_core.yml/runs \
              --paginate \
              -q '.workflow_runs[] | select(.status == "in_progress") | .id' | head -n 1)

          if [[ -z "$runID" ]]; then
            echo "No in-progress run found yet. Retrying in 10 seconds..."
            sleep 10
            continue
          fi

          echo "run_id=$runID" >> $GITHUB_OUTPUT
          echo "Found in-progress workflow with RUN_ID: $run_id"
          break
        done

    # Wait for the workflow to complete
    - name: Wait for the Triggered Workflow Finish
      if: steps.check-asset-existence.outcome != 'success'
      env:
        REPO: "MikroElektronika/sdk_automation"
        GH_TOKEN: ${{ secrets.MIKROE_ACTIONS_KEY }}
      run: |
        while : ; do
          STATUS=$(gh api \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              repos/$REPO/actions/runs/${{ steps.get_id.outputs.run_id }} \
              -q '.status')

          CONCLUSION=$(gh api \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              repos/$REPO/actions/runs/${{ steps.get_id.outputs.run_id }} \
              -q '.conclusion')

          echo "Workflow status: $STATUS"

          if [[ "$STATUS" == "completed" ]]; then
            echo "Workflow completed with conclusion: $CONCLUSION"
            break
          fi

          # Wait for a few seconds before checking again
          sleep 10
        done

        # Check the conclusion and fail the job if the triggered workflow failed
        if [[ "$CONCLUSION" != "success" ]]; then
          echo "Triggered workflow failed with conclusion: $CONCLUSION"
          exit 1
        fi

        echo "Triggered workflow completed successfully!"

    # Aquire the asset that we just generated with the sdk_automation script
    - name: Fetch asset
      run: gh release download --repo MikroElektronika/sdk_automation latest --pattern 'extracted_${{ steps.upper-mcu-name.outputs.mcu_name }}.zip'
      env:
        GH_TOKEN: ${{ secrets.MIKROE_ACTIONS_KEY }}

    # Move the asset we just downloaded to automatization and extract it
    - name: Move to the created directory unzip and distribute files
      id: move_files
      run: |
        sudo mv extracted_${{ steps.upper-mcu-name.outputs.mcu_name }}.zip automatization/
        cd automatization
        unzip extracted_${{ steps.upper-mcu-name.outputs.mcu_name }}.zip

        mkdir -p ../${{ github.event.inputs.architecture }}/gcc_clang/def/${{ github.event.inputs.vendor }}/${{ github.event.inputs.mcu_name }}
        mkdir -p ../${{ github.event.inputs.architecture }}/gcc_clang/interrupts/include/interrupts_mcu/${{ github.event.inputs.mcu_name }}
        mkdir -p ../${{ github.event.inputs.architecture }}/gcc_clang/system/src/${{ github.event.inputs.vendor }}/doc_ds_1

        sudo mv 'mcu.h' ../${{ github.event.inputs.architecture }}/gcc_clang/def/${{ github.event.inputs.vendor }}/${{ github.event.inputs.mcu_name }}/
        echo "json_name=$(basename $(find . -maxdepth 1 -name '*.json' | head -n 1))" >> $GITHUB_OUTPUT
        sudo mv "$(find . -maxdepth 1 -name '*.json' | head -n 1)" ../${{ github.event.inputs.architecture }}/gcc_clang/def/
        sudo mv 'interrupts_mcu.h' ../${{ github.event.inputs.architecture }}/gcc_clang/interrupts/include/interrupts_mcu/${{ github.event.inputs.mcu_name }}/
        sudo mv 'init_clock.c' ../${{ github.event.inputs.architecture }}/gcc_clang/system/src/${{ github.event.inputs.vendor }}/doc_ds_1/
        sudo mv "$(find . -maxdepth 1 -name '*.ld' | head -n 1)" ../${{ github.event.inputs.architecture }}/gcc_clang/linker_scripts/${{ github.event.inputs.vendor }}/
        sudo mv "$(find . -maxdepth 1 -name '*.s' | head -n 1)" ../${{ github.event.inputs.architecture }}/gcc_clang/startup/${{ github.event.inputs.vendor }}/
        sudo mv "$(find . -maxdepth 1 -name '*.cmake' | head -n 1)" ../${{ github.event.inputs.architecture }}/gcc_clang/cmake/${{ github.event.inputs.vendor }}/
        cd delays
        sudo mv "$(find . -maxdepth 1 -name '*.cmake' | head -n 1)" ../../${{ github.event.inputs.architecture }}/gcc_clang/cmake/${{ github.event.inputs.vendor }}/delays/
        cd ..

    - name: Create new core for delays if necessary
      run: |
        CORE=$(jq -r '.core' ./${{ github.event.inputs.architecture }}/gcc_clang/def/${{ steps.move_files.outputs.json_name }} | tr '[:upper:]' '[:lower:]')
        if [ -d "./${{ github.event.inputs.architecture }}/gcc_clang/delays/$CORE" ]; then
          echo "Core already exists: $CORE"
        else
          mkdir "./${{ github.event.inputs.architecture }}/gcc_clang/delays/$CORE"
          sudo mv './${{ github.event.inputs.architecture }}/gcc_clang/delays/m4/delays.c' ./${{ github.event.inputs.architecture }}/gcc_clang/delays/$CORE/
          echo "Found new core: $CORE"
        fi

    # Commit changes
    - name: Commit changes
      run: |
        git add .
        git commit -m "Pulled files from sdk_automation into core_packages"

    # Push changes back to your repository
    - name: Push changes
      run: |
        git push -u origin ${{ github.event.inputs.build_branch }}
